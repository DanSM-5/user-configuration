#!/usr/bin/env bash

######################################
#        GENERAL CONFIGURATION       #
######################################

# Follow structure conf folders and files
user_conf_path="$HOME/.usr_conf"
user_scripts_path="$HOME/user-scripts"
prj="$HOME/prj"

backup_path () {
  export PATH_BACKUP=$(echo -n $PATH | tr ":" "\n")
}

# Separate path entries that start with /mnt/
set_windows_path () {
  export WIN_PATH=$(echo -n $PATH_BACKUP | rg "/mnt/" | sed ':a; N; $!ba; s/\n/:/g')
}

set_unix_path () {
  export UNIX_PATH=$(echo -n $PATH_BACKUP | rg "/mnt/" --invert-match | sed ':a; N; $!ba; s/\n/:/g')
}

set_path () {
  export PATH="$1"
}

path_append ()  { path_remove $1; export PATH="$PATH:$1"; }
path_prepend () { path_remove $1; export PATH="$1:$PATH"; }
path_remove ()  { export PATH=`echo -n $PATH | awk -v RS=: -v ORS=: '$0 != "'$1'"' | sed 's/:$//'`; }

detect_shell () {
  echo "Loading..."
  echo "Running from shell: $SHELL"
  echo

  if [ -n "$ZSH_VERSION" ]; then
    export IS_ZSH=true
    export IS_BASH=false
    export SHELL_NAME=zsh
    test -f "$user_conf_path/.zsh_conf" && source "$user_conf_path/.zsh_conf"
  elif [ -n "$BASH_VERSION" ]; then
    export IS_ZSH=false
    export IS_BASH=true
    export SHELL_NAME=bash
    test -f "$user_conf_path/.bash_conf" && source "$user_conf_path/.bash_conf"
  else
    echo "[WARNING]: NO VALID CONFIGURATION DETECTED!"
    export IS_ZSH=false
    export IS_BAHS=false
    export SHELL_NAME=unknown
  fi
}

set_linux () {
  if command -v "/home/linuxbrew/.linuxbrew/bin/brew" &> /dev/null; then
    # Linux brew
    eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"

    # oh-my-posh requires brew
    if command -v oh-my-posh &> /dev/null && test -f ~/omp-theme/jandedobbeleer.omp.v2.json; then
      eval "$(oh-my-posh --init --shell $SHELL_NAME --config ~/omp-theme/jandedobbeleer.omp.v2.json)"
    fi

    local brew_nvm=$(brew --prefix nvm)
  fi

  # NVM configuration (Bash only)
  if [ "$IS_BASH" = "true" ]; then
    export NVM_DIR="$HOME/.nvm"
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
    [ -s "$brew_nvm/etc/bash_completion.d/nvm" ] && \. "$brew_nvm/etc/bash_completion.d/nvm"  # This loads nvm bash_completion from brew
  fi

  # Setup wsl specifics
  # if [ "$IS_WSL" = true ]; then
  #   set_wsl
  # fi
}

set_wsl () {
  echo no implemented &> /dev/null
}

set_mac () {
  export BASH_SILENCE_DEPRECATION_WARNING=1
  if command -v brew &> /dev/null; then
    # NVM configuration
    export NVM_DIR="$HOME/.nvm"
    local nvm_path=$(brew --prefix nvm)
    [ -s $nvm_path/nvm.sh ] && source $nvm_path/nvm.sh
    [ -s $nvm_path/etc/bash_completion.d/nvm ] && source $nvm_path/etc/bash_completion.d/nvm
  fi

  # Set color output
  if [ -d "$(brew --prefix coreutils)" ]; then
    test -r ~/.dircolors && eval "$(gdircolors -b ~/.dircolors)" || eval "$(gdircolors -b)"
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
  fi
}

set_general () {
  export COLORTERM='truecolor'

  # enable color support of ls and also add handy aliases
  if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
  fi

  # colored GCC warnings and errors
  #export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

  # make less more friendly for non-text input files, see lesspipe(1)
  [ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"


  # set PATH so it includes user's provate bin if it exists
  # if [ -d "$HOME/bin" ]; then
  export PATH="$HOME/bin:$PATH"
  # fi

  # set PATH so it includes user's provate bin if it exists
  # if [ -d "$HOME/.local/bin" ]; then
  export PATH="$HOME/.local/bin:$PATH"
  # fi

  if command -v register-python-argcomplete &> /dev/null; then
    eval "$(register-python-argcomplete pipx)"
  fi

  if command -v starship &> /dev/null; then
    eval "$(starship init $SHELL_NAME)"
  fi

  # For envman. Do not edit.
  [ -s "$HOME/.config/envman/load.sh" ] && source "$HOME/.config/envman/load.sh"

  if command -v bat &> /dev/null; then
    export MANPAGER="sh -c 'col -bx | bat -l man -p'"
  fi

  # fzf support
  if command -v rg &> /dev/null; then
    FD_OPTIONS="--follow --exclude .git --exclude node_modules"
    export FZF_DEFAULT_COMMAND='rg --files --no-ignore --hidden --follow --glob "!.git"'
    export FZF_CTRL_T_COMMAND="fd $FD_OPTIONS"
    export FZF_ALT_C_COMMAND="fd --type d $FD_OPTIONS"
  fi

  # To install useful key bindings and fuzzy completion:
  # $(brew --prefix)/opt/fzf/install # call only once
  # case $SHELL_NAME in
  #   zsh)  test -f ~/.fzf.zsh && source ~/.fzf.zsh;;
  #   bash) test -f ~/.fzf.bash && source ~/.fzf.bash;;
  # esac
}

set_general_after () {
  if [ -f "$HOME/.fzf.$SHELL_NAME" ]; then
    source "$HOME/.usr_conf/utils/fzf-git.sh"
  fi
}

# initialize shell
detect_shell

# Should be called system agnostic
set_general

# Set device specific
case "$(uname)" in
  Linux*) set_linux;;
  Darwin*) set_mac;;
esac

set_general_after

