#!/usr/bin/env bash

######################################
#        GENERAL CONFIGURATION       #
######################################

# Follow structure conf folders and files
user_conf_path="$HOME/.usr_conf"
user_scripts_path="$HOME/user-scripts"
prj="$HOME/prj"

backup_path () {
  export PATH_BACKUP=$(echo -n $PATH | tr ":" "\n")
}

# Separate path entries that start with /mnt/
set_windows_path () {
  export WIN_PATH=$(echo -n $PATH_BACKUP | rg "/mnt/" | sed ':a; N; $!ba; s/\n/:/g')
}

set_unix_path () {
  export UNIX_PATH=$(echo -n $PATH_BACKUP | rg "/mnt/" --invert-match | sed ':a; N; $!ba; s/\n/:/g')
}

set_path () {
  export PATH="$1"
}

path_append ()  { path_remove $1; export PATH="$PATH:$1"; }
path_prepend () { path_remove $1; export PATH="$1:$PATH"; }
path_remove ()  { export PATH=`echo -n $PATH | awk -v RS=: -v ORS=: '$0 != "'$1'"' | sed 's/:$//'`; }

detect_shell () {
  # echo "Loading..."
  # echo "Running from shell: $SHELL"

  if [ -n "$ZSH_VERSION" ]; then
    export IS_ZSH=true
    export IS_BASH=false
    export SHELL_NAME=zsh
    test -f "$user_conf_path/.zsh_conf" && source "$user_conf_path/.zsh_conf"
  elif [ -n "$BASH_VERSION" ]; then
    export IS_ZSH=false
    export IS_BASH=true
    export SHELL_NAME=bash
    test -f "$user_conf_path/.bash_conf" && source "$user_conf_path/.bash_conf"
  else
    echo "[WARNING]: NO VALID CONFIGURATION DETECTED!"
    export IS_ZSH=false
    export IS_BAHS=false
    export SHELL_NAME=unknown
  fi
}

set_linux () {
  # export IS_LINUX=true
  if command -v "/home/linuxbrew/.linuxbrew/bin/brew" &> /dev/null; then
    # Linux brew
    eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"

    # oh-my-posh requires brew
    if command -v oh-my-posh &> /dev/null && test -f ~/omp-theme/jandedobbeleer.omp.v2.json; then
      eval "$(oh-my-posh --init --shell $SHELL_NAME --config ~/omp-theme/jandedobbeleer.omp.v2.json)"
    fi

    local brew_nvm=$(brew --prefix nvm)
  fi

  # NVM configuration (Bash only)
  if [ "$IS_BASH" = "true" ]; then
    export NVM_DIR="$HOME/.nvm"
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
    [ -s "$brew_nvm/etc/bash_completion.d/nvm" ] && \. "$brew_nvm/etc/bash_completion.d/nvm"  # This loads nvm bash_completion from brew
  fi

  # Setup wsl specifics
  # if [ "$IS_WSL" = true ]; then
  #   set_wsl
  # fi
}

set_wsl () {
  :
}

set_gitbash () {
  # Enable oh-my-posh if available
  if command -v oh-my-posh &> /dev/null && test -f ~/omp-theme/jandedobbeleer.omp.v2.json; then
    eval "$(oh-my-posh --init --shell $SHELL_NAME --config ~/omp-theme/jandedobbeleer.omp.v2.json)"
  fi

  # Load fzf-git
  [ -f "$HOME/.usr_conf/utils/fzf-git.sh" ] && source "$HOME/.usr_conf/utils/fzf-git.sh"

  # Load fzf helpers
  # [ -f "$HOME/.fzf.bash" ] && source "$HOME/.fzf.bash"
}

set_termux () {
  :
}

set_mac () {
  # export IS_MAC=true
  export BASH_SILENCE_DEPRECATION_WARNING=1
  if command -v brew &> /dev/null; then
    # NVM configuration
    export NVM_DIR="$HOME/.nvm"
    local nvm_path=$(brew --prefix nvm)
    [ -s $nvm_path/nvm.sh ] && source $nvm_path/nvm.sh
    [ -s $nvm_path/etc/bash_completion.d/nvm ] && source $nvm_path/etc/bash_completion.d/nvm
  fi

  # Set color output
  if [ -d "$(brew --prefix coreutils)" ]; then
    test -r ~/.dircolors && eval "$(gdircolors -b ~/.dircolors)" || eval "$(gdircolors -b)"
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
  fi
}



set_general () {
  export PREFERED_EDITOR='nvim'
  export EDITOR="$PREFERED_EDITOR"
  export COLORTERM='truecolor'
  export BAT_THEME='Dracula'
  # dark='--color=bg+:#3F3F3F,bg:#4B4B4B,border:#6B6B6B,spinner:#98BC99,hl:#719872,fg:#D9D9D9,header:#719872,info:#BDBB72,pointer:#E12672,marker:#E17899,fg+:#D9D9D9,preview-bg:#3F3F3F,prompt:#98BEDE,hl+:#98BC99'
  # light='--color=bg+:#D9D9D9,bg:#E1E1E1,border:#C8C8C8,spinner:#719899,hl:#719872,fg:#616161,header:#719872,info:#727100,pointer:#E12672,marker:#E17899,fg+:#616161,preview-bg:#D9D9D9,prompt:#0099BD,hl+:#719899'
  gruvbox='--color="bg+:#3c3836,bg:#32302f,spinner:#fb4934,hl:#928374,fg:#ebdbb2,header:#928374,info:#8ec07c,pointer:#fb4934,marker:#fb4934,fg+:#ebdbb2,prompt:#fb4934,hl+:#fb4934"'
  # nord_vim='--color=bg+:#3B4252,bg:#2E3440,spinner:#81A1C1,hl:#616E88,fg:#D8DEE9,header:#616E88,info:#81A1C1,pointer:#81A1C1,marker:#81A1C1,fg+:#D8DEE9,prompt:#81A1C1,hl+:#81A1C1'
  # molokai='--color=bg+:#293739,bg:#1B1D1E,border:#808080,spinner:#E6DB74,hl:#7E8E91,fg:#F8F8F2,header:#7E8E91,info:#A6E22E,pointer:#A6E22E,marker:#F92672,fg+:#F8F8F2,prompt:#F92672,hl+:#F92672'
  export FZF_DEFAULT_OPTS="--height 80% --layout=reverse --border $gruvbox"

  # enable color support of ls and also add handy aliases
  if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
  fi

  # colored GCC warnings and errors
  #export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

  # make less more friendly for non-text input files, see lesspipe(1)
  [ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

  # set PATH so it includes user's provate bin if it exists
  # if [ -d "$HOME/bin" ]; then
  export PATH="$HOME/bin:$PATH"
  # fi

  # set PATH so it includes user's provate bin if it exists
  # if [ -d "$HOME/.local/bin" ]; then
  export PATH="$HOME/.local/bin:$PATH"
  # fi

  if [ -d "$HOME/.bun" ]; then
    # bun completions
    [ -s "$HOME/.bun/_bun" ] && source "$HOME/.bun/_bun"

    # bun
    export BUN_INSTALL="$HOME/.bun"
    export PATH="$BUN_INSTALL/bin:$PATH"
  fi


  # To install useful key bindings and fuzzy completion:
  # $(brew --prefix)/opt/fzf/install # call only once
  # case $SHELL_NAME in
  #   zsh)  test -f ~/.fzf.zsh && source ~/.fzf.zsh;;
  #   bash) test -f ~/.fzf.bash && source ~/.fzf.bash;;
  # esac
}

set_general_after () {
  if [ -f "$HOME/.fzf.$SHELL_NAME" ]; then
    source "$HOME/.usr_conf/utils/fzf-git.sh"
  fi

  if command -v register-python-argcomplete &> /dev/null; then
    eval "$(register-python-argcomplete pipx)"
  fi

  if command -v starship &> /dev/null; then
    eval "$(starship init $SHELL_NAME)"
  fi

  # For envman. Do not edit.
  [ -s "$HOME/.config/envman/load.sh" ] && source "$HOME/.config/envman/load.sh"

  # fzf support
  if command -v rg &> /dev/null; then
    export FZF_DEFAULT_COMMAND='rg --files --no-ignore --hidden --glob "!node_modules" --glob "!.git" --follow'
  fi

  if command -v fd &> /dev/null; then
    FD_OPTIONS="--follow --exclude .git --exclude node_modules"
    export FZF_CTRL_T_COMMAND="fd $FD_OPTIONS"
    export FZF_ALT_C_COMMAND="fd --type d $FD_OPTIONS"

    _fzf_compgen_path () {
      fd --hidden --follow --exclude "node_modules" --exclude ".git" . "$1"
    }

    # Use fd to generate the list for directory completion
    _fzf_compgen_dir () {
      fd --type d --hidden --follow --exclude "node_modules" --exclude ".git" . "$1"
    }
  fi

  if command -v rga &> /dev/null; then
    rga-fzf() {
    RG_PREFIX="rga --files-with-matches"
    local file
    file="$(
    FZF_DEFAULT_COMMAND="$RG_PREFIX '$1'" \
      fzf --sort --preview="[[ ! -z {} ]] && rga --pretty --context 5 {q} {}" \
      --phony -q "$1" \
      --bind "change:reload:$RG_PREFIX {q}" \
      --preview-window="70%:wrap"
          )" &&
            echo "opening $file" &&
            xdg-open "$file"
          }
  fi

  if command -v bat &> /dev/null; then
    export MANPAGER="sh -c 'col -bx | bat -l man -p'"
  fi
}

# initialize shell
detect_shell

# Should be called system agnostic
set_general

# Set device specific
case "$(uname)" in
  Linux*) set_linux;;
  Darwin*) set_mac;;
  *NT*) set_gitbash;;
esac

set_general_after

