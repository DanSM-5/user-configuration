#!/usr/bin/env bash

######################################
#           GENERAL ALIAS            #
######################################

# Follow structure conf folders and files
export user_conf_path="${user_conf_path:-"$HOME/.usr_conf"}"
export user_scripts_path="${user_scripts_path:-"$HOME/user-scripts"}"
export prj="${prj:-"$HOME/prj"}"
export user_config_cache="${user_config_cache:-"$HOME/.cache/.user_config_cache"}"

# shellcheck disable=SC2139
alias gpr="cd '$prj'"
# shellcheck disable=SC2139
alias gus="cd '$user_scripts_path'"
# shellcheck disable=SC2139
alias guc="cd '$user_conf_path'"
# shellcheck disable=SC2139
alias gvc="cd '$HOME/vim-config'"
# alias gvc="cd $HOME/.SpaceVim.d"
# shellcheck disable=SC2139
alias goh="cd '$HOME'"

uconf="$user_conf_path/.uconfrc"
uconfg="$user_conf_path/.uconfgrc"
ualias="$user_conf_path/.ualiasrc"
ualiasg="$user_conf_path/.ualiasgrc"

cmd () {
  :
}

fzf-defaults () {
  # --bind ctrl-/:toggle-preview \
  # --preview-window '~4,+{2}+4/3,<80(up)'
  fzf --height 80% --min-height 20 --border \
    --input-border \
    --bind 'alt-f:first' \
    --bind 'alt-l:last' \
    --bind 'alt-c:clear-query' \
    --bind 'ctrl-^:toggle-preview' \
    --bind 'ctrl-/:change-preview-window(down|hidden|)' \
    --bind 'alt-up:preview-page-up,alt-down:preview-page-down' \
    --bind 'ctrl-s:toggle-sort' \
    --header 'Press CTRL-/ to toggle preview' \
    "$@"
}

# Previews command
fzf_preview_normal="$user_conf_path/utils/fzf-preview.sh {}"

fd-defaults () {
  local fd_show=($(command cat "$user_conf_path/fzf/fd_show"))
  local fd_exclude=($(command cat "$user_conf_path/fzf/fd_exclude"))

  fd \
    "${fd_show[@]}" \
    "${fd_exclude[@]}" \
    "$@"
}

PREFERRED_EDITOR="${PREFERRED_EDITOR:-vim}"

# shellcheck disable=SC2139
alias epf="$PREFERRED_EDITOR '$HOME/.profile'"
# shellcheck disable=SC2139
alias ecf="$PREFERRED_EDITOR '$uconf'"
# shellcheck disable=SC2139
alias egc="$PREFERRED_EDITOR '$uconfg'"
# shellcheck disable=SC2139
alias eal="$PREFERRED_EDITOR '$ualias'"
# shellcheck disable=SC2139
alias ega="$PREFERRED_EDITOR '$ualiasg'"
# shellcheck disable=SC2139
alias evc="$PREFERRED_EDITOR '$HOME/vim-config/vimstart.vim'"
# alias evc="$PREFERRED_EDITOR $HOME/.SpaceVim.d/init.toml"
# shellcheck disable=SC2139
alias ezsh="$PREFERRED_EDITOR '$user_conf_path/.zsh_conf'"
# shellcheck disable=SC2139
alias ebash="$PREFERRED_EDITOR '$user_conf_path/.bash_conf'"

# Git
alias glg="git log --oneline --decorate --graph"
alias glga="git log --oneline --all --decorate --graph"
alias gcommit="git commit -m"
alias gcomm="git commit"
alias gfetch="git fetch"
alias gpull="git pull"
alias gupdate="git fetch && git pull"
alias gpush="git push"
alias gadd="git add"
alias greset="git reset"
alias gbranch="git branch"
alias grebase="git rebase"
alias gmerge="git merge"
alias gco="git checkout"
alias gck="git checkout"
alias grm="git checkout -- ."
alias gamend="git commit --amend"
alias gdif="git diff"
alias gstash="git stash"
alias gsl="git stash list"
alias gsa="git stash apply"
alias gspop="git stash pop"
alias gsp="git stash push -m"
alias gss="git stash show"
alias gsd="git stash drop"
alias egt="git config -e"
alias egtg="git config --global -e"

grepo () {
  git rev-parse HEAD > /dev/null 2>&1 || return

  git "$@"
}

alias g="git"

gstatus () {
  grepo status "$@"
}

alias gs="gstatus"

gsv () {
  gstatus -v "$@"
}

# Git status short version
gsb () {
  gstatus -sb "$@"
}

# Show cache
gdc () {
  grepo diff --cached
}
gdf () {
  grepo diff
}

get_bare_repository () {
  local current_directory="$PWD"
  local toplevel
  local bare_root
  local is_bare_repository=false

  if [ "$(git rev-parse --is-bare-repository 2>/dev/null)" = true ]; then
    is_bare_repository=true
    if ! [ -f config ]; then
      # Navigate up until fin the root
      while ! [ "$PWD" = "/" ]; do
        # Check if is a bare repo
        if [ "$(git rev-parse --is-bare-repository 2>/dev/null)" = true ] && [ -f config ]; then
          bare_root="$PWD"
          break
        fi
        # If error, it means we are no longer under a git repository
        if [ "$?" -ne 0 ]; then
          printf '%s' "Could not find the root of the bare repository"
          return
        fi
        # Move up a directory
        cd ..
      done
    else
      bare_root="$PWD"
    fi
  else
    # Check if any parent directoy (up to the root) is a bare repo
    while ! [ "$PWD" = "/" ]; do
      # Check if is a bare repo
      if [ "$(git rev-parse --is-bare-repository 2>/dev/null)" = true ]; then
        # Not savig $PWD here because it could be an intermediate directory
        is_bare_repository=true
        break
      fi
      # If error, it means we are no longer under a git repository
      if [ "$?" -ne 0 ]; then
        break
      fi
      # Move up a directory
      cd ..
    done

    # Recover current dir
    cd "$current_directory" || return

    if [ "$is_bare_repository" = false ]; then
      printf "%s\n" "Not in a bare repository" > /dev/stderr
      return
    fi

    toplevel="$(git rev-parse --show-toplevel)"
    if ! [ -f "$toplevel/.git" ]; then
      printf "%s\n" "Cannot find .git file" > /dev/stderr
      return
    fi

    bare_root="$(awk '{ print $2 }' "$toplevel/.git")"
    bare_root="${bare_root%/worktrees*}"

    if ! [ -d "$bare_root" ]; then
      printf "%s\n" "Cannot find location of bare repository" > /dev/stderr
      return
    fi

    # Test if detected directory is bare repository
    pushd "$bare_root" &>/dev/null || return
    if ! [ "$(git rev-parse --is-bare-repository 2>/dev/null)" = true ]; then
      printf "%s\n" "Wrongly detecting '$bare_root' as root of bare repository" > /dev/stderr
      popd || return
      return
    fi
    popd &>/dev/null || return
  fi

  printf '%s' "$bare_root"
}

alias gcr="get_bare_repository"

# Bare repo checkout
gwc () {
  local bare_root branch_name

  bare_root="$(get_bare_repository)"

  # Didn't find any bare repository
  if [ -z "$bare_root" ]; then
    return 1
  fi

  # Go to bare root
  pushd "$bare_root" &>/dev/null || return 1

  if [ "$1" = "-b" ]; then
    branch_name="$2"
    [ ! -d "$branch_name" ] &&
      git worktree add -b "$branch_name" "$branch_name" "${@:3}"
  else
    branch_name="$1"
    [ ! -d "$branch_name" ] &&
      git worktree add "$branch_name" "$branch_name" "${@:2}"
  fi

  # Recover previous location
  popd || return

  # Attempt to cd into new worktree
  cd "$bare_root/$branch_name" 2>/dev/null || return
}

fwc () {
  local selection branch_name

  selection=$(fgb "${*:-}")

  # while IFS='' read -r branch; do
  #   selection="$branch"
  # done < <(fgb "${*:-}")

  if [ -z "$selection" ]; then
    return
  fi

  # Clean branch name
  branch_name="${selection//origin\//}"

  if [[ $selection =~ ^origin\/ ]]; then
    gwc "$branch_name" --track
  else
    gwc "$branch_name"
  fi
}

fwr () {
  local selection
  local bare_root
  local branch_name

  bare_root="$(get_bare_repository)"

  if [ -z "$bare_root" ]; then
    return 1
  fi

  selection=($(fgb "${*:-}"))

  if [ -z "${selection[*]}" ]; then
    return
  fi

  for branch in "${selection[@]}"; do
    # Clean branch name
    branch_name="${branch//origin\//}"

    git worktree remove "$branch_name"
  done
}

if command_exists delta; then
  alias gprev="git diff HEAD^..HEAD | delta"
else
  alias gprev="git diff HEAD^..HEAD | bat"
fi

gprevd () {
  local limit="$1"

  # Default limit: 1
  if [ -z "$limit" ] || [ "$limit" -le 0 ]; then
    limit=1
  fi

  if command_exists delta; then
    git diff HEAD~"$limit"..HEAD | delta
  else
    git diff HEAD~"$limit"..HEAD | bat
  fi
}

gprevr () {
  local first="$1"
  local second="$2"

  # Default first: 1
  if [ -z "$first" ] || [ "$first" -le 0 ]; then
    first=1
  fi

  # Default second: 0
  if [ -z "$second" ] || [ "$second" -le 0 ]; then
    second=0
  fi

  if command_exists delta; then
    git diff HEAD~"$first"..HEAD~"$second" | delta
  else
    git diff HEAD~"$first"..HEAD~"$second" | bat
  fi
}

fadd () {
  local selection
  local ifsog="$IFS"
  IFS="
" selection=( $(fgf "${*:-}" | sed 's/^\"//' | sed 's/\"$//') )
  IFS="$ifsog"

  # selection=()
  # while IFS='' read -r pathspec; do
  #   selection+=("$pathspec")
  # done < <(fgf "${*:-}" | sed 's/^\"//' | sed 's/\"$//')

  echo "${selection[@]}"
  # shellcheck disable=SC2128
  if [ -n "$selection" ]; then
    git add "${selection[@]}"
  fi
}

fpad () {
  local selection
  local ifsog="$IFS"
  IFS="
" selection=( $(fgf "${*:-}" | sed 's/^\"//' | sed 's/\"$//') )
  IFS="$ifsog"

  # selection=()
  # while IFS='' read -r pathspec; do
  #   selection+=("$pathspec")
  # done < <(fgf "${*:-}" | sed 's/^\"//' | sed 's/\"$//')

  echo "${selection[@]}"
  # shellcheck disable=SC2128
  if [ -n "$selection" ]; then
    git add -p "${selection[@]}"
  fi
}

fco () {
  local selection
  selection=$(fgb "${*:-}")

  # while IFS='' read -r branch_name; do
  #   selection="$branch_name"
  # done < <(fgb "${*:-}")

  if [ -n "$selection" ]; then
    git checkout "${selection//origin\//}"
  fi
}

fck () {
  local selection
  selection=$(fgb "${*:-}")

  # while IFS='' read -r branch_name; do
  #   selection="$branch_name"
  # done < <(fgb "${*:-}")

  if [ -n "$selection" ]; then
    git checkout "${selection//origin\//}"
  fi
}

fgrm () {
  local selection
  selection=($(fgf "${*:-}"))

  # local selection=()
  # while IFS='' read -r pathspec; do
  #   selection+=("$pathspec")
  # done < <(fgf "${*:-}")

  echo "Reverting: ${selection[*]}"

  # shellcheck disable=SC2128
  if [ -n "$selection" ]; then
    git checkout -- "${selection[@]}"
  fi
}

fmerge () {
  local selection
  selection=$(fgb "${*:-}")

  # while IFS='' read -r branch_name; do
  #   selection="$branch_name"
  # done < <(fgb "${*:-}")

  echo "$selection"

  if [ -n "$selection" ]; then
    git merge "$selection"
  fi
}

fsa () {
  local selection
  selection=$(fgs "${*:-}")

  # while IFS='' read -r stash_ref; do
  #   selection="$stash_ref"
  # done < <(fgb "${*:-}")

  if [ -n "$selection" ]; then
    git stash apply "$selection"
  fi
}

if command_exists eza; then
  alias ll="eza -AlF --icons --group-directories-first"
  alias la="eza -AF --icons --group-directories-first"
  alias l="eza -F --icons --group-directories-first"
else
  alias ll='ls -AlhF '
  alias la='ls -AF'
  alias l='ls -F'
fi

# General commands
alias mkdr="mkdir -pv"
alias fzfp="fzf-defaults --preview-window '60%' --preview '$fzf_preview_normal'"
alias pvim="vim --clean"
alias pnvim="nvim --clean"

frm () {
  local selection
  selection=($(fd-defaults --color=always -tf -tl |
    fzf-defaults --ansi --cycle --multi \
      --preview-window '60%' \
      --preview "$fzf_preview_normal"))

  # while IFS='' read -r to_rm_file; do
  #   selection+=("$to_rm_file")
  # done < <(fd-defaults --color=always -tf -tl |
  #   fzf-defaults --ansi --cycle --multi \
  #     --preview-window '60%' \
  #     --preview "$fzf_preview_normal")

  # shellcheck disable=SC2128
  if [ -z "$selection" ]; then
    return
  fi

  \rm "${selection[@]}"
}

frdr () {
  local selection
  selection=($(fd-defaults --color=always -td -d 1 |
    fzf-defaults --ansi --cycle \
      --preview-window '60%' \
      --preview "$fzf_preview_normal"))

  # while IFS='' read -r dir_to_rm; do
  #   selection+=("$dir_to_rm")
  # done < <(fd-defaults --color=always -td -d 1 |
  #   fzf-defaults --ansi --cycle \
  #     --preview-window '60%' \
  #     --preview "$fzf_preview_normal")

  # shellcheck disable=SC2128
  if [ -z "$selection" ]; then
    return
  fi

  \rm -rf "${selection[@]}"
}

rfv () {
  "$user_conf_path/utils/rgfzf.sh" "$@"
}

fll () {
  local selection
  selection=$(fd-defaults --color=always -td |
    fzf-defaults --ansi --cycle \
      --preview-window '60%' \
      --preview "$fzf_preview_normal")
  if [ -n "$selection" ]; then
    \ls -alhF  --color=always "$selection"
  fi
}

lfd () {
  fd-defaults --color=always |
    fzf-defaults --ansi --cycle \
      --preview-window '60%' \
      --preview "$fzf_preview_normal"
}

# experimental
lfa () {
  local selection
  selection=$(cd "/" && fd-defaults --color=always |
    fzf-defaults --ansi --cycle \
      --preview-window '60%' \
      --preview "$fzf_preview_normal")
  echo "$selection"
}

fcd () {
  local location="${1:-.}"
  local query="${*:2}"
  local pattern="."
  local selection=""

  if ! [ -d "$location" ]; then
    pattern="$location"
    location="$HOME"
  fi

  # old preview "ls --color=always -alhF {} | sed '1d;2d;3d'"
  selection=$(fd-defaults --color=always -tl -td "$pattern" "$location" |
    fzf-defaults --ansi --cycle --query "$query" \
      --header "(ctrl-/) Search in: $location" \
      --preview-window '60%' \
      --preview "$fzf_preview_normal")
  if [ -z "$selection" ]; then
    return 1
  fi

  cd "$selection" || return
}

# sed '1d;2d'
# fcdd () {
#   local query="$*"
#   local selection=""

#   selection=$(fd-defaults --color=always -tl -td |
#     fzf-defaults --ansi --cycle \
#       --query "$query" \
#       --preview-window '60%' \
#       --preview "$fzf_preview_normal")

#   if [ -z "$selection" ]; then
#     return 1
#   fi

#   cd "$selection" || return
# }

# fcde () {
#   local location="${1:-.}"
#   local pattern="${2:-.}"
#   local query="${*:3}"
#   local selection

#   if ! [ -d "$location" ]; then
#     echo "Invalid location. Defaulting to cwd."
#     location="."
#   fi

#   selection=$(
#     fd-defaults -L -tf "$pattern" "$location" \
#       -x dirname {} |
#     sort -u |
#     fzf-defaults \
#       --preview-window '60%' \
#       --preview "$fzf_preview_normal" \
#       --header "(ctrl-/) Search in: $location" \
#       --query "$query")
#   if [ -z "$selection" ]; then
#     return
#   fi

#   cd "$selection" || return
# }

# fcda () {
#   local selection=""

#   selection=$(cd / && fd-defaults -tl -td |
#     fzf-defaults \
#       --preview-window '60%' \
#       --preview "$fzf_preview_normal")
#   if [ -n "$selection" ]; then
#     cd "$selection" || return
#   fi
# }

# fed () {
#   local location="${1:-.}"
#   local query="${*:3}"
#   local pattern="."
#   local editor="${PREFERRED_EDITOR:-vim}"

#   if ! [ -d "$location" ]; then
#     pattern="$location"
#     location="$HOME"
#   fi

#   local selection
#   selection=($(fd-defaults --color=always -L -tf "$pattern" "$location" |
#     fzf-defaults \
#       --ansi \
#       --cycle \
#       --multi \
#       --preview-window '60%' \
#       --preview "$fzf_preview_normal" \
#       --header "(ctrl-/) Search in: $location" \
#       --query "$query"))

#   # while IFS='' read -r new_line; do
#   #   selection+=("$new_line")
#   # done < <(fd-defaults --color=always -L -tf "$pattern" "$location" |
#   #   fzf-defaults \
#   #     --ansi \
#   #     --cycle \
#   #     --multi \
#   #     --preview-window '60%' \
#   #     --preview "$fzf_preview_normal" \
#   #     --header "(ctrl-/) Search in: $location" \
#   #     --query "$query")

#   # shellcheck disable=SC2128
#   if [ -z "$selection" ]; then
#     return
#   fi
#   if [ -n "$2" ] && [ "$2" != "-" ]; then
#     editor="$2"
#   fi

#   "$editor" "${selection[@]}"
# }

# fedd () {
#   local query="${*:2}"
#   local editor="${PREFERRED_EDITOR:-vim}"
#   local selection=$(fd-defaults --color=always -L -tf |
#     fzf-defaults --multi --ansi --cycle \
#       --preview-window '60%' \
#       --preview "$fzf_preview_normal" --query "$query")
#   if [ -z "$selection" ]; then
#     return
#   fi
#   if [ -n "$1" ] && [ "$1" != "-" ]; then
#     editor="$1"
#   fi
#   "$editor" "${selection[@]}"
# }

fif () {
  if [ ! "$#" -gt 0 ]; then
    echo 'Need a string to search for!'
    return 1;
  fi

  rg --color=always --files-with-matches --no-messages "$*" |
    fzf-defaults \
      --ansi --cycle \
      --preview-window '60%' \
      --preview "
        highlight -O ansi -l {} 2> /dev/null |
        rg --colors 'match:bg:yellow' --ignore-case --pretty --context 10 '$*' || rg --ignore-case --pretty --context 10 '$*' {}"
}

fdirs () {
  local selection="$(dirs -v |
    fzf-defaults \
      --cycle \
      --preview-window '60%' \
      --preview "$fzf_preview_normal {2..}" |
    awk '{print $1}')"

  if [ -n "$selection" ]; then
    pushd "+$selection" || return
  fi
}

fenv () {
  local tmpfile
  tmpfile="$(mktemp)"
  # Cleanup file on exit
  trap "rm -- '$tmpfile'" EXIT

  while IFS='=' read -r -d '' n v; do
    printf "%s=%s\n" "$n" "${v//$'\n'}"
  done < <(env -0) > "$tmpfile"


  # FZF process
  # --expect will return an arry with the expected key
  # as first element if key is pressed
  local output=($(cat -v "$tmpfile" |
    fzf-defaults \
      --preview 'printf "%q" {}' \
      --preview-window 'up:50%:hidden:wrap' \
      --bind 'ctrl-/:toggle-preview' \
      --bind 'ctrl-s:toggle-sort' \
      --bind 'ctrl-y:execute-silent(echo -n {} | $clipboard_copy)+abort' \
      --expect 'ctrl-h,ctrl-v' \
      --color header:italic \
      --header 'CTRL-Y: Copy | CTRL-V: Value | CTRL-H: Key'))

  # Subshell to keep helper functions as local
  (
    getKey () {
      cut -d '=' -f "1" | trim
    }

    getValue () {
      cut -d '=' -f "2-" | trim
    }

    case ${output[1]} in
      ctrl-h)
        # Print key only
        echo "${output[@]:1}" | getKey
        ;;
      ctrl-v)
        # Print value only
        echo "${output[@]:1}" | getValue
        ;;
      *)
        # Print everything if selected
        if [ -n "${output[1]}" ]; then
          echo "${output[@]}"
        fi
        ;;
    esac
  )
}

fnr () {
  if ! [ -f package.json ]; then
    echo "No package.json in dir $(pwd)"
    return 1
  fi

  local runner="${1:-npm}"
  local query="${@:2}"

  # Escope for local functions
  (
    case "$runner" in
      m|pnpm|mr) runner_func () { pnpm run "$@"; };;
      n|npm|nr|-) runner_func () { npm run "$@"; };;
    esac

    local value_script="
      val={};
      jq -r \".scripts[\\\"\$val\\\"]\" < package.json
    "
    local copy_script="$value_script | clip-copy"

    local selection="$(jq -r '.scripts | keys[]' < package.json |
      sort |
      fzf --no-multi --query "$query" \
        --preview-window 'up:3:hidden:wrap' \
        --bind 'ctrl-/:toggle-preview,ctrl-s:toggle-sort' \
        --bind "ctrl-y:execute-silent(clip-copy {})+abort" \
        --bind "ctrl-u:execute-silent($copy_script)+abort" \
        --preview "$value_script" \
        --height 50% --min-height 20 --border)"

    if [ -z "$selection" ]; then
      return 0
    fi

    runner_func "$selection"
  )
}

# Example quick_access
# export quick_access=(
# "$HOME"
# # "/mnt/c\n"
# # "/mnt/c/Users/user"
# "$prj"
# "$user_conf_path"
# "$user_scripts_path"
# # "/tmp"
# )

# Example quick_edit
# export quick_edit=(
# "$user_conf_path/.uconfgrc"
# "$user_conf_path/.uconfrc"
# "$user_conf_path/.ualiasgrc"
# "$user_conf_path/.ualiasrc"
# "$HOME/.SpaceVim.d/init.toml"
# "$HOME/.SpaceVim.d/autoload/config.vim"
# )

# List folders for quick navigation
# Requires: quick_access=()
qnv () {
  if [ -z "$quick_access" ]; then
    return
  fi
  local selection=$(printf "%s\n" "${quick_access[@]}" |
    fzf-defaults \
      --preview-window '60%' \
      --preview "$fzf_preview_normal")

  if [ -n "$selection" ]; then
    cd "$selection" || return
  fi
}

# List files for quick edit
# Requires: quick_edit
qed () {
  if [ -z "$quick_edit" ]; then
    return
  fi
  local editor="$1"
  local selection=$(printf "%s\n" "${quick_edit[@]}" |
    fzf-defaults \
      --preview-window '60%' \
      --preview "$fzf_preview_normal")

  if ! [ -f "$selection" ]; then
    return
  fi
  if [ -z "$editor" ]; then
    editor="${PREFERRED_EDITOR:-vim}"
  fi
  $editor "$selection"
}

cprj () {
  # local return_dir="$1"
  # local directories=($("$user_conf_path/utils/getprojects"))

  # if [ -z "${directories[*]}" ]; then
  #   return
  # fi

  # local fd_show=""
  # local fd_exclude=""
  # while IFS= read -r line_fd_show; do
  #   fd_show="$fd_show $line_fd_show"
  # done < "$user_conf_path/fzf/fd_show"
  # while IFS= read -r line_fd_exclude; do
  #   fd_exclude="$fd_exclude $line_fd_exclude"
  # done < "$user_conf_path/fzf/fd_show"
  # local fd_command="fd --color=always --type file $fd_show $fd_exclude . {}"
  # local reload_command="$user_conf_path/utils/getprojects"

  # # if [ "$IS_WINSHELL" = true ]; then
  # #   local win_user_conf="$(cygpath -am "$user_conf_path")"
  # #   local reload_command="pwsh -NoLogo -NonInteractive -NoProfile -File $win_user_conf/utils/getprojects.ps1"
  # # else
  # #   local reload_command="$user_conf_path/utils/getprojects"
  # # fi

  # local selection=($(printf "%s\n" "${directories[@]}" |
  #   fzf-defaults \
  #     "--history=$FZF_HIST_DIR/cprj" \
  #     --no-multi \
  #     --ansi --cycle \
  #     --info=inline \
  #     --header 'CTRL-R: Reload | CTRL-F: Files | CTRL-O: Open | CTRL-Y: Copy' \
  #     --prompt 'Projs> ' \
  #     --bind "ctrl-f:change-prompt(Files> )+reload($fd_command)+clear-query+change-multi+unbind(ctrl-f)" \
  #     --bind "ctrl-r:change-prompt(Projs> )+reload($reload_command)+rebind(ctrl-f)+clear-query+change-multi(0)" \
  #     --bind "ctrl-o:execute-silent(\"$user_scripts_path/bin/start\" {})+abort" \
  #     --bind "ctrl-y:execute-silent(\"$user_conf_path/utils/copy-helper\" \"{+f}\")+abort" \
  #     --bind 'alt-a:select-all' \
  #     --bind 'alt-d:deselect-all' \
  #     --bind 'alt-f:first' \
  #     --bind 'alt-l:last' \
  #     --bind 'alt-c:clear-query' \
  #     --preview-window '60%' \
  #     --preview "$fzf_preview_normal" \
  # ))

  # # --bind 'alt-a:select-all' \
  # # --bind 'alt-d:deselect-all' \
  # if [ -z "$selection" ]; then
  #   return
  # fi

  # if [ "$return_dir" = '-r' ]; then
  #   printf '%s\n' "${selection[@]}"
  #   return
  # fi

  local selection
  local ifsog="$IFS"
  IFS="
" selection=($(gprj))
  IFS="$ifsog"

  if [ -z "$selection" ]; then
    return
  fi

  if ! [ -d "$selection" ]; then
    "$PREFERRED_EDITOR" "${selection[@]}"
    return
  fi

  cd "${selection[@]}" || return
}

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Sys Alias
alias aptup="sudo apt-get update && sudo apt-get upgrade"
alias aptupd="sudo apt-get update"
alias aptupg="sudo apt-get upgrade"
alias aptin="sudo apt-get install"
alias aptrm="sudo apt-get remove"

# Node & NPM
alias npm-list="npm list -g --dept=0"
alias nlg="npm list -g --dept=0"
alias nr="npm run"
alias mr="pnpm run"

# Navigation
# Nav up n directories
up () {
  local d=""
  local limit="$1"

  # Default to limit of 1
  if [ -z "$limit" ] || [ "$limit" -le 0 ]; then
    limit=1
  fi

  for (( i=1; i<=limit; i++ )); do
    d="../$d"
  done

  # perdorm cd. Show error if cd fails
  if ! cd "$d"; then
    echo "Couldn't go up $limit dirs."
  fi
}

.. () {
  up "$@"
}

... () {
  up 2
}

# Sourcing
alias spf="source '$HOME/.${SHELL_NAME}rc' || source '$HOME/.profile' || echo 'Source profile encountered an error'"
alias scfg="source '$user_conf_path/.uconfrc'"
alias sgcf="source '$user_conf_path/.uconfgrc'"
alias sals="source '$user_conf_path/.ualiasrc'"
alias sgal="source '$user_conf_path/.ualiasgrc'"

if [ "$IS_GITBASH" = true ]; then
  if [ "$IS_ZSH" = true ]; then
    alias refrenv="source '$user_conf_path/utils/refrenvz.sh'"
  else
    alias refrenv="source '$user_conf_path/utils/refrenv.sh'"
  fi
fi

# Trim utilities
nospace () {
  tr -d "[:space:]"
}

ltrim () {
  sed -E 's/^[[:space:]]*//'
}

rtrim () {
  sed -E 's/[[:space:]]*$//'
}

trim () {
  ltrim | rtrim
}

# extract files
ex () {
  # $1 must be file name
  # all other arguments are passed to the respective utility
  if [ -f "$1" ]; then
    case $1 in
      *.tbz)        tar xjvf "$1" "${@:2}";;
      *.tar.bz2)    tar xjvf "$1" "${@:2}";;
      *.tar.bz)     tar xjvf "$1" "${@:2}";;
      *.tbz2)       tar xjvf "$1" "${@:2}";;
      *.tar.gz)     tar xzvf "$1" "${@:2}";;
      *.tgz)        tar xzvf "$1" "${@:2}";;
      *.bz2)        bunzip2 "$1" "${@:2}";;
      *.rar)        unrar x "$1" "${@:2}";;
      *.gz)         gunzip "$1" "${@:2}";;
      *.tar)        tar xvf "$1" "${@:2}";;
      *.zip)        unzip "$1" "${@:2}";;
      *.Z)          uncompress "$1" "${@:2}";;
      *.7z)         7z x "$1" "${@:2}";;
      *.iso)        7z x "$1" "${@:2}";;
      *.deb)        ar x "$1" "${@:2}";;
      *.tar.xz)     tar xJvf "$1" "${@:2}";;
      *.txz)        tar xJvf "$1" "${@:2}";;
      *.tar.zst)    unzstd "$1" "${@:2}";;
      *.ipk)        tar zxpvf "$1" "${@:2}";;
      *.wgt)        unzip "$1" "${@:2}";;
      *.apk)        apktool d "$1" "${@:2}";;
      *)            echo "'$1' cannot be extracted via ex command!";;
    esac
  else
    echo "'$1' is not a file"
  fi
}

archive () {
  atype="$1"

  case "$atype" in
    tar)   tar cvf "$2" "${@:3}";;
    tgz)   tar czvf "$2" "${@:3}";;
    7z)    7z a "$2" "${@:3}";;
    zip)   zip -r "$2" "${@:3}";;
    rar)   rar a "$2" "${@:3}";;
    *) echo "Archive type '$1' not supported by archive command!"
  esac
}

# System executables
export clipboard_paste=""
export clipboard_copy=""
gallery_dl_commd="gallery-dl"
yt_dlp_commd="yt-dlp"
mpv_commd='mpv'
toru_commd='toru'

# Standard wrapper function names that should work on all platforms
clipboard_pastew () {
  "$clipboard_paste" "$@"
}
clipboard_copyw () {
  "$clipboard_copy" "$@"
}

file_explorer_open () {
  :
}

gallery-dlw () {
  "$gallery_dl_commd" "$@"
}

yt-dlpw () {
  "$yt_dlp_commd" "$@"
}

yt-dlp-play () {
  "$yt_dlp_commd" -o - "$@"
}

yt-dlp-play-quality () {
  yt-dlp-play -f bestvideo+bestaudio/best "$@"
}

mpvw () {
  echo "Playing: $*"
  "$mpv_commd" "$@"
}

webtorrentw () {
  webtorrent "$@"
}

toruw () {
  "$toru_commd" "$@"
}

mpvp () {
  # mpv play
  # declare url=${*:-$(</dev/stdin)}
  local use_stdin=false
  for arg do
    shift
    if [[ "$arg" = "-" ]]; then
      # Remove - arg
      use_stdin=true
      continue
    fi
    set -- "$@" "$arg"
  done

  if [ "$use_stdin" = true ]; then

    read -t 5 url
    if [ -z "$url" ]; then
      echo "No url provided"
      (exit 1) && true
    fi

    echo "Playing: $url"
    yt-dlp-play-quality "$url" | "$mpv_commd" --cache "${@:2}"  -
  elif [ -n "$1" ]; then
    echo "Playing: $1"
    yt-dlp-play-quality "$1" | "$mpv_commd" --cache "${@:2}"  -
  else
    echo "No url provided"
    (exit 1) && true
  fi
}

dwi () {
  local img_url="$("$clipboard_paste" | trim)"
  if [ -z "$img_url" ]; then
    echo "No image url"
    return 1
  fi

  echo "Downloading: $img_url"

  "$gallery_dl_commd" "$img_url" "$@"
}

dwv () {
  local vid_url="$("$clipboard_paste" | trim)"
  if [ -z "$vid_url" ]; then
    echo "No video url"
    return 1
  fi

  echo "Downloading: $vid_url" "$@"

  "$yt_dlp_commd" "$@" "$vid_url"
}

dgl () {
  Download-Gdl "$@"
}

dyl () {
  Download-Ydl "$@"
}

# Wrapper for ytfzf to launch mpv player
mpvl () {
  local selection=$(ytfzf -L "$@")
  if [ -n "$selection" ]; then
    "$mpv_commd" "$selection"
  fi
}

yf () {
  # Set starting page with flag -p[n]
  local startpage=1
  local direct_play=false
  local linkOnly=false
  local selection=""
  for arg do
    shift
    if [[ "$arg" =~ -p[0-9]+ ]]; then
      # Remove -p arg and use value as pages_start
      startpage="${arg:2}"
      continue
    elif [[ "$arg" = "--direct-play" ]]; then
      direct_play=true
      continue
    elif [[ "$arg" = "-L" ]]; then
      # -L is always called in this wrapper
      # Detect it here to prevent playback
      linkOnly=true
    fi
    set -- "$@" "$arg"
  done

  if [[ "$linkOnly" = false ]] && [[ "$direct_play" = true ]]; then
    selection="$(pages_start="$startpage" ytfzf -L "$@")"

    if [ -z "$selection" ]; then
      return 1
    fi

    mpvp "$selection"
    return
  fi

  pages_start="$startpage" ytfzf "$@"
}

yfd () {
  yf --direct-play "$@"
}

play () {
  local url="$("$clipboard_paste" | trim)"
  if [ -z "$url" ]; then
    echo "No url in clipboard"
    return 1
  fi

  if [[ "$url" =~ .torrent$ ]]; then
    toruw stream --torrent "$url" "$@"
    return 0
  fi

  if [[ "$url" =~ ^magnet: ]]; then
    toruw stream --magnet "$url" "$@"
    return 0
  fi

  # if [[ "$url" =~ ".torrent" ]] ||
  # [[ "$url" =~ "magnet:" ]] ||
  if [[ "$url" =~ "webtorrent://" ]] ||
  [[ "$url" =~ "peerflix://" ]]; then
    webtorrentw --mpv "$url" "$@"

    return 0
  fi

  mpvw "$url" "$@"
}

plpp () {
  local url="$("$clipboard_paste")"
  if [ -z "$url" ]; then
    echo "No url in clipboard"
    return 1
  fi
  mpvp "$url" "$@"
}

tplay () {
  local url="$("$clipboard_paste" | trim)"
  if [ -z "$url" ]; then
    echo "No url in clipboard"
    return 1
  fi

  if [[ "$url" =~ .torrent$ ]]; then
    toruw stream --torrent "$url" "$@"
    return 0
  fi

  if [[ "$url" =~ ^magnet: ]]; then
    toruw stream --magnet "$url" "$@"
    return 0
  fi


  if [ "$1" = '-l' ]; then
    webtorrentw --mpv "$url" -u 1 "${@:2}"
  else
    webtorrentw --mpv "$url" "$@"
  fi
}

getHostPath () {
  local input="$*"
  local filepath="$(echo "$input" | tr -d "\r\n")"

  if [ -z "$filepath" ]; then
    echo ""
    return
  fi

  if [[ -f "$filepath" ]]; then
    filepath="$(dirname "$filepath")"
  elif [[ -d "$filepath" ]]; then
    :
  else
    echo ""
    return
  fi

  echo "$(realpath "$filepath")"
}

getPath () {
  getHostPath "$@"
}

getSystemClipboardPath () {
  getHostPath "$($clipboard_paste)"
}

getClipboardPath () {
  local filepath="$("$clipboard_paste" | tr -d "\r\n")"

  if [ -z "$filepath" ]; then
    echo ""
    return
  fi

  if [[ -f "$filepath" ]]; then
    filepath="$(dirname "$filepath")"
  elif [[ -d "$filepath" ]]; then
    :
  else
    echo ""
    return
  fi

  echo "$(realpath "$filepath")"
}

ccd () {
  local filepath="$(getClipboardPath)"

  if [[ -z "$filepath" ]]; then
    echo "None or wrong path provided"
    return 1
  fi

  cd "$filepath" || return
}

ocd () {
  local filepath="$(getClipboardPath)"

  if [[ -z "$filepath" ]]; then
    echo "None or wrong path provided"
    return 1
  fi

  file_explorer_open "$filepath"
}

getTempDir () {
  echo "/tmp"
}

ptc () {
  local location="${1:-.}" # Current location
  local query="${@:2}"
  local pattern="."
  local selection=""

  if ! [ -d "$location" ]; then
    pattern="$location"
    location="$HOME"
  fi

  # old preview "ls --color=always -alhF {} | sed '1d;2d;3d'"
  selection=$({ echo '.'; fd-defaults --color=always -tl -td -tf -L "$pattern" "$location"; } |
    fzf-defaults --query "$query" \
      --ansi --cycle \
      --header "(ctrl-/) Search in: $location" \
      --preview-window '60%' \
      --preview "$fzf_preview_normal")
  if [ -z "$selection" ]; then
    return 1
  fi

  selection="$(realpath "$selection")"

  echo "$selection" | clipboard_copyw
}

unset_if_function () {
  local command_name="$1"

  if command_exists "$command_name"; then
    if [ "$IS_ZSH" = true ] && [[ $(type "$command_name") =~ function ]]; then
      unset -f "$command_name"
    elif [ "$IS_BASH" = true ] && [[ $(type -t "$command_name") == function ]]; then
      unset -f "$command_name"
    fi
  fi
}

# Small wrapper to emulate
# python launcher from windows
py () {
  local first="$1"
  local interpreter="python3"

  case "$first" in
    -0)
      {
        # Show all python versions
        (whereis python  | awk '{for (i=2; i<=NF; i++) print $i}' &) 2> /dev/null
        (whereis python2 | awk '{for (i=2; i<=NF; i++) print $i}' &) 2> /dev/null
        (whereis python3 | awk '{for (i=2; i<=NF; i++) print $i}' &) 2> /dev/null
        ( (printf "%s\n" /usr/bin/python*) 2> /dev/null &)
        (which python 2> /dev/null &)
        (which python3 2> /dev/null &)
      } | sort -u
      return
      ;;
    -2*) ;&
    -3*)
      shift
      interpreter="python${first:1}"
      ;;
  esac

  "$interpreter" "$@"
}

if command -v apt &>/dev/null; then
  show_packages () {
    dpkg-query -W -f='${Package}\n' |
      fzf-defaults \
        --preview-window '60%' \
        --preview 'apt-cache show {} | bat --style=plain --color=always --language yml' \
        --layout=reverse \
        --cycle \
        --bind 'enter:execute(apt-cache show {} | bat --style=plain --color=always --paging=always --language yml)'
  }
elif command -v pacman &>/dev/null; then
  show_packages () {
    # For all explicitly installed packages:
    # pacman -Qqe | fzf --preview 'pacman -Qil {}' --layout=reverse --bind 'enter:execute(pacman -Qil {} | less)'
    #
    # Additionally, this displays explicitly installed packages that are not currently required by any other package:
    # pacman -Qqet | fzf --preview 'pacman -Qil {}' --layout=reverse --bind 'enter:execute(pacman -Qil {} | less)'
    #
    # This shows explicitly installed packages from official Arch repos only:
    # pacman -Qqen | fzf --preview 'pacman -Qil {}' --layout=reverse --bind 'enter:execute(pacman -Qil {} | less)'
    #
    # This shows explicitly installed packages from foreign repos only (AUR, Chaotic AUR, etc)
    # pacman -Qqem | fzf --preview 'pacman -Qil {}' --layout=reverse --bind 'enter:execute(pacman -Qil {} | less)'

    pacman -Qq | fzf-defaults \
      --layout=reverse \
      --preview-window '60%' \
      --preview 'pacman -Qil {} | bat --style=plain --color=always' \
      --cycle \
      --bind 'enter:execute(pacman -Qil {} | bat --style=plain --color=always)'
  }
fi

if [ "$IS_WINDOWS" = true ]; then
  ptc () {
    local location="${1:-.}" # Current location
    local query="${@:2}"
    local pattern="."
    local selection=""

    if ! [ -d "$location" ]; then
      pattern="$location"
      location="$HOME"
    fi

    # old preview "ls --color=always -alhF {} | sed '1d;2d;3d'"
    selection=$({ echo '.'; fd-defaults --color=always -tl -td -tf -L "$pattern" "$location"; } |
      fzf-defaults --ansi --cycle --query "$query" \
        --header "(ctrl-/) Search in: $location" \
        --preview-window '60%' \
        --preview "$fzf_preview_normal")

    if [ -z "$selection" ]; then
      return 1
    fi

    selection="$(realpath "$selection")"

    getHostPath "$selection" | tr '\\' '/' | clipboard_copyw
  }
fi

if [ "$IS_WSL" = true ]; then
  alias psh="powershell.exe"
  alias cps="pwsh.exe -nolo -nopro -nonin -c"
  alias pwsh="pwsh.exe"
  alias start-docker="sudo service docker start"

  export clipboard_paste="pbpaste.exe"
  export clipboard_copy="pbcopy.exe"

  gallery_dl_commd="gallery-dl.exe"
  yt_dlp_commd="yt-dlp.exe"
  mpv_commd='mpv'

  dgl () {
    # Setting location to windows to avoid
    # issues launching gallery-dl if using windows binary
    pushd "$WIN_HOME" || return
    Download-Gdl "$@"
    popd || return
  }

  cmd () {
    cmd.exe /c "$@"
  }

  file_explorer_open () {
    pwsh.exe -nolo -nonin -nopro -c "Start-Process $*"
  }

  start () {
    # local filepath="$(echo "$@" | trim)"
    # if [ -f "$filepath" ] || [ -d "$filepath" ]; then
    #   # Convert path to host version
    #   filepath="$(getHostPath "$filepath")"
    # fi

    # file_explorer_open "$filepath"

    local item="$(printf "%s" "$@" | sed -E 's/^[[:space:]]*//' | sed -E 's/[[:space:]]*$//')"

    if [ -f "$item" ] || [ -d "$item" ]; then
      item="$(sed "s|wslpath: ||g" <<< "$(wslpath -aw "$item" 2>&1)")"
    fi

    pwsh.exe -NoLogo -NonInteractive -NoProfile -Command "Start-Process $item"
  }

  unset_if_function mpv

  # MPV wrapper for WSL
  if ! command_exists mpv; then
    if command_exists mpv.com; then
      mpv_commd="mpv.com"
      mpv () {
        mpv.com "$@"
      }

    elif command_exists mpv.exe; then
      mpv_commd="mpv.exe"
      mpv () {
        mpv.exe "$@"
      }
    fi
  fi

  # yt-dlp wrapper for WSL
  if ! command_exists yt-dlp; then
    yt-dlp () {
      yt-dlp.exe "$@"
    }
  fi

  # gallery-dl wrapper for WSL
  if ! command_exists gallery-dl; then
    gallery-dl () {
      gallery-dl.exe "$@"
    }
  fi

  unset_if_function toru

  # toru wrapper for WSL
  if ! command_exists toru; then
    toru_commd='toru.exe'

    toru () {
      toru.exe "$@"
    }
  fi

  webtorrentw () {
    cmd webtorrent "$@"
  }

  # Windows override of yf
  yf () {
    # Set starting page with flag -p[n]
    local startpage=1
    local linkOnly=false
    local direct_play=false
    for arg do
      shift
      if [[ "$arg" =~ -p[0-9]+ ]]; then
        # Remove -p arg and use value as pages_start
        startpage="${arg:2}"
        continue
      elif [[ "$arg" = "-L" ]]; then
        # -L is always called in this wrapper
        # Detect it here to prevent playback
        linkOnly=true
        continue
      elif [[ "$arg" = "--direct-play" ]]; then
        direct_play=true
        continue
      fi
      set -- "$@" "$arg"
    done

    local selection="$(pages_start="$startpage" ytfzf -L "$@")"

    if [ -z "$selection" ]; then
      return 1
    fi

    if [[ "$linkOnly" = true ]]; then
      echo "$selection"
      return
    elif [[ "$direct_play" = true ]]; then
      mpvp "$selection"
    else
      mpvw "$selection"
    fi
  }

  linuxToWindowsPath () {
    wslpath -aw "$1"
  }

  windowsToLinuxPath () {
    wslpath -au "$1"
  }

  getHostPath () {
    local input="$*"
    local filepath="$(trim <<< "$input" | tr -d "\r\n")"

    if [ -z "$filepath" ]; then
      echo ""
      return
    fi

    local linuxpath="" windowspath=""

    if [[ -f "$filepath" ]] || [[ -d "$filepath" ]]; then # Valid unix path
      linuxpath="$(wslpath -au "$(wslpath -aw $filepath)")"
    else # win path
      linuxpath="$(wslpath -au "$filepath")"
    fi

    if [ -d "$linuxpath" ]; then
      windowspath="$(wslpath -aw "$linuxpath")"
      # wslpath -aw "$linuxpath"
    elif [ -f "$linuxpath" ]; then
      windowspath="$(dirname "$linuxpath" | xargs -i wslpath -aw {})"
      # dirname "$linuxpath" | xargs -i wslpath -aw {}
    fi

    # Return escaped string to allow \f \n \t directories
    # echo "$(printf "%q" "$windowspath" | sed 's/\\ / /g')"
    sed -r -e 's/\\(f|t|u)/\\\\\1/g' <<< "$windowspath"
  }

  getPath () {
    local input="$*"
    local win_path="$(getHostPath "$input")"

    printf "%q" "$(wslpath -ua "$win_path")"
  }

  getSystemClipboardPath () {
    getPath "$($clipboard_paste)"
  }

  getClipboardPath () {
    getHostPath "$($clipboard_paste)"
  }

  ccd () {
    local filepath="$(getClipboardPath)"

    if [[ -z "$filepath" ]]; then
      echo "None or wrong path provided"
      return 1
    fi

    cd "$(wslpath -au "$filepath")" || return
  }

  # ocd () {
  #   local filepath="$("$clipboard_paste" | tr -d "\r\n" )"

  #   if [ -z "$filepath" ]; then
  #     return 1
  #   fi

  #   local linuxpath="" windowspath=""

  #   if [[ -f "$filepath" ]] || [[ -d "$filepath" ]]; then # Valid unix path
  #     linuxpath="$(wslpath -au "$(wslpath -aw $filepath)")"
  #   else # win path
  #     linuxpath="$(wslpath -au "$filepath")"
  #   fi

  #   if [ -d "$linuxpath" ]; then
  #     local windowspath="$(wslpath -aw "$linuxpath")"
  #   elif [ -f "$linuxpath" ]; then
  #     local windowspath="$(dirname "$linuxpath" | xargs -i wslpath -aw {})"
  #   else
  #     echo "Invalid path"
  #     return 1
  #   fi

  #   pwsh.exe -nolo -nonin -nopro -c Start-Process \""$windowspath"\"
  # }

  getTempDir () {
    pushd "$WIN_HOME" &> /dev/null || return
    local dir_path="$(cmd.exe /c "echo %TEMP%" | sed 's/\\ / /g' | sed -e 's/[[:space:]]*$//')"
    popd &> /dev/null || return
    printf "%q" "$(wslpath -au "$dir_path")"
  }

else

  # function for compliancy
  mpvl () {
    ytfzf "$@"
  }

  if [ "$IS_TERMUX" = true ]; then
    alias tcopy="termux-clipboard-set"
    alias tpaste="termux-clipboard-get"
    export clipboard_copy="termux-clipboard-set"
    export clipboard_paste="termux-clipboard-get"

    start () {
      file_explorer_open "$@"
    }

    clipboard_copyw () {
      termux-clipboard-set "$@"
    }

    clipboard_pastew () {
      termux-clipboard-get "$@"
    }

    # termux mpv function wrapper
    mpv () {
      local use_stdin=false

      for arg do
        shift
        if [[ "$arg" = "-" ]]; then
          # Remove -p arg and use value as pages_start
          use_stdin=true
          continue
        fi
        set -- "$@" "$arg"
      done

      if [ "$use_stdin" = true ]; then

        read -t 5 url
        if [ -z "$url" ]; then
          echo "No url provided"
          (exit 1) && true
        fi

        am start --user 0 -a android.intent.action.VIEW -d "$url" is.xyz.mpv/.MPVActivity
      elif [ -n "$1" ]; then
        am start --user 0 -a android.intent.action.VIEW -d "$@" is.xyz.mpv/.MPVActivity
      else
        echo "No url provided"
        (exit 1) && true
      fi
    }
  elif [ "$IS_LINUX" = true ]; then
    start () {
      # Previous - new xdg-open
      # file_explorer_open "$@"
      xdg-open "$@" &
    }

    clipboard_copyw () {
      xsel -ib "$*"
    }

    clipboard_pastew () {
      xsel -ob "$@"
    }

    export clipboard_copy="$user_conf_path/utils/copy-helper-linux.sh"
    export clipboard_paste="$user_conf_path/utils/paste-helper-linux.sh"

    file_explorer_open () {
      xdg-open "$@" &
    }

    alias start-docker="sudo service docker start"

  elif [ "$IS_MAC" = true ]; then
    export clipboard_copy="pbcopy"
    export clipboard_paste="pbpaste"

    start () {
      open "$@"
    }

    file_explorer_open () {
      open "$@"
    }

  elif [ "$IS_GITBASH" = true ]; then
    export clipboard_copy="pbcopy"
    export clipboard_paste="pbpaste"

    # Gitbash should be able to use
    # Window's python launcher
    unset_if_function py

    # Show scoop packages on gitbash
    show_packages () {
      local selection
      local packages=($(scoop list | awk 'NR>4 {print $1}'))

      while true; do
        selection="$(printf "%s\n" "${packages[@]}" | fzf-defaults \
          --cycle \
          --preview-window '60%' \
          --preview 'scoop info {}' \
        )"

        if [ -z "$selection" ]; then
          break
        fi

        scoop info "$selection" | bat --color=always --paging=always --style=plain
        selection=
      done
    }

    file_explorer_open () {
      # Special parsing for windows paths
      local location_path="$(printf "%q" "$@" |
        trim |
        sed -re "s|^/([a-zA-Z])/(.*$)|\u\1:/\2|g" |
        tr '/' '\\')"

      location_path="$(printf "%q" "$location_path" | sed 's/\\ / /g')"

      pwsh.exe -nolo -nonin -nopro -c "Start-Process $location_path"
    }

    getSystemClipboardPath () {
      getPath "$($clipboard_paste)"
    }

    getPath () {
      local input="$*"
      local filepath="$(echo "$input" | tr -d "\r\n")"

      if [ -z "$filepath" ]; then
        echo ""
        return
      fi

      if [[ -f "$filepath" ]]; then
        filepath="$(dirname "$filepath")"
      elif [[ -d "$filepath" ]]; then
        :
      else
        echo ""
        return
      fi

      if [[ "$filepath" =~ : ]]; then
        local drive_letter="$(sed -rn 's#^([A-Za-z]):.*#\1#p' <<< "$filepath" | tr '[:upper:]' '[:lower:]')"
        filepath="/${drive_letter}/${filepath:3}"
      fi

      printf "%s" "$(realpath "$filepath")"
    }

    getHostPath () {
      local filepath="$(getPath "$@")"

      if [ -z "$filepath" ]; then
        echo ""
        return
      elif ! [ -f "$filepath" ] && ! [ -d "$filepath" ]; then
        echo ""
        return
      fi

      local windowspath=""
      local drive_letter=""

      if ! [[ "$filepath" =~ : ]]; then
        drive_letter="$(sed -rn 's#^/([A-Za-z])/.*#\1#p' <<< "$filepath" | tr '[:lower:]' '[:upper:]')"
        windowspath="${drive_letter}:${filepath:2}"
      else
        windowspath="$filepath"
      fi

      # Return escaped string to allow \f \n \t directories
      echo "$(printf "%q" "$windowspath" | sed 's/\\ / /g')"
    }

    cmd () {
      cmd.exe //c "$@"
    }

    getClipboardPath () {
      local filepath="$("$clipboard_paste" | tr -d "\r\n")"

      if [ -z "$filepath" ]; then
        echo ""
        return
      fi

      if [[ -f "$filepath" ]]; then
        filepath="$(dirname "$filepath")"
      elif [[ -d "$filepath" ]]; then
        :
      else
        echo ""
        return
      fi

      if [[ "$filepath" =~ ^// ]]; then
        printf "%s" "$filepath"
      else
        printf "%s" "$(realpath "$filepath")"
      fi
    }

    if [ "$IS_ZSH" = true ]; then
      alias refrenv="source '$user_conf_path/utils/refrenvz.sh'"
    else
      alias refrenv="source '$user_conf_path/utils/refrenv.sh'"
    fi

  fi
fi

fmpv () {
  local mpv_args="$*"
  local selection
  local ifsog="$IFS"
  IFS="
" selection=($(fd -tf --color=always |
    fzf --multi --ansi --cycle \
      --info=inline \
      --height 80% --min-height 20 \
      --preview-window '60%' \
      --preview "$fzf_preview_normal" \
      --bind "ctrl-/:change-preview-window(down|hidden|),alt-up:preview-page-up,alt-down:preview-page-down,ctrl-s:toggle-sort" \
      --bind 'alt-f:first' \
      --bind 'alt-l:last' \
      --bind 'alt-c:clear-query' \
      --border))
  IFS="$ifsog"

  if [ -z "${selection[*]}" ]; then
    return
  fi

  local quoted=$(printf '%s\n' "${selection[@]}" |
    awk '{ printf "\"""%s""\""" ", $0 }')
  bash -c "$mpv_commd $mpv_args -- $quoted"
}

# If path issues, add VS Code path manually
# export PATH="${WIN_HOME}/AppData/Local/Programs/Microsoft VS Code/bin:$PATH"

# Dependencies
# export PATH="$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

getShellAliasAndFunctions () {

  # compgen -a # will list all the aliases you could run.
  # compgen -A function # will list all the functions you could run.
  # compgen -A variable # will list all the variables defined.
  #
  # For bash but will work in zsh if enable
  # > autoload -U bashcompinit
  # > bashcompinit
  # in zshrc
  #
  # Ref: https://unix.stackexchange.com/questions/292903/list-names-of-aliases-functions-and-variables-in-zsh

  if [ "$IS_BASH" = true ]; then
    {
      # Functions
      typeset -F | awk '{ if ( $3 !~ /_.+/) { print $3 } }';
      # Aliases
      # alias | awk '{ split($2,o,"="); print o[1] }'
      compgen -a
    }
  else
    {

      # Functions
      # NOTE: if using fast-syntax-highlighting the functions check won't work
      # print -l ${(ok)functions} |
      #   awk '{ if ($1 !~ /^_.+/) { print $1 } }';
      # Aliases
      # alias | cut -d '=' -f 1
      # print -rl -- ${(k)aliases} ${(k)functions} ${(k)parameters}

      # Functions
      compgen -A function |
        awk '{ if ($1 !~ /^[→_-].+/) { print $1 } }';
      # Aliases
      compgen -a
    }
  fi
}

fcmd () {
  local available_commands=($(getShellAliasAndFunctions | sort))
  local tmpfile="$(mktemp)"
  # Cleanup file on exit
  trap "rm -- '$tmpfile'" EXIT

  # Get the output of type and store it in tmpfile
  for cm in "${available_commands[@]}"; do
    echo ""
    type -f "$cm" 2>/dev/null || type "$cm" 2>/dev/null
  done > "$tmpfile"

  # --preview "rg -A 20 -B 1 --text --color=always '^{} ' $tmpfile" \
  printf '%s\n' "${available_commands[@]}" |
    fzf-defaults \
      --preview "
        item={}
        if [ \"\$item\" = '..' ]; then
          item='\\.\\.';
        elif [ \"\$item\" = '...' ]; then
          item='\\.\\.\\.';
        fi
        rg -A 100 -B 1 -m 1 \"^\$item \" $tmpfile |
          bat -l bash --color=always -p -H 2" \
      --preview-window right:70% \
      --bind 'ctrl-y:execute-silent(echo -n {} | $clipboard_copy)+abort' || return 0
}

pfn () {
  declare -f | perl -0777 -pe 's/^}\n/}\0/gm' |
    awk -v ORS='\0' -v RS='\0' '!/^[→_-]/' |
    bat --plain --language bash --color always |
    fzf --read0 --ansi --reverse --multi --highlight-line
}

fnvm () {
  local nvm_version=$(nvm list | fzf --ansi | awk '{ if ($1 == "->") print $2; else print $1; }')

  if [ -n "$nvm_version" ]; then
    nvm use "$nvm_version"
  fi
}

# TODO: Using `fd --hidden --follow -td -d 1`
# has issues with file names with spaces.
# Investigate if fixin the issue is faster
countFiles () {
  local searchSize="$1"
  local fdArgs=(${@:2})

  (
    printSimple () {
      printf "$1\t$(fd --hidden "${fdArgs[@]}" . "$1" | wc -l)\n"
    }

    printWithFileSize () {
      local count="$(fd --hidden "${fdArgs[@]}" . "$1" | wc -l)"
      printf "$(du -sh "$1" 2> /dev/null)\t$count\n"
    }

    local printFunc=printSimple

    if [ "$searchSize" = true ]; then
      printFunc=printWithFileSize
    fi

    local fd_show=($(command cat "$user_conf_path/fzf/fd_show"))
    local fd_exclude=($(command cat "$user_conf_path/fzf/fd_exclude"))

    for dirl in $(fd "${fd_show[@]}" "${fd_exclude[@]}" -td -d 1); do
    # for dirl in .*/ */; do
      "$printFunc" "$dirl"
    done | column -t -s $'\t'
  )
}

cdirs () {
  printf '%s' "Counting directories in $(pwd):"
  local size=false
  [ "$1" = -s ] && size=true
  countFiles "$size" -td
}

cfiles () {
  printf '%s\n\n' "Counting files in $(pwd):"
  [ "$1" = -s ] && size=true
  countFiles "$size" -tf
}

cevery () {
  printf '%s\n\n' "Counting all files in $(pwd):"
  [ "$1" = -s ] && size=true
  countFiles "$size"
}

bdif () {
  git rev-parse HEAD > /dev/null 2>&1 || return

  git diff --name-only --relative --diff-filter=d | xargs bat --diff
}

publicip () {
  curl checkip.amazonaws.com
}

# cd when exit lf
lfcd () {
  if command -v lf &> /dev/null; then
    # `command` is needed in case `lfcd` is aliased to `lf`
    local path_on_exit="$(command lf -print-last-dir "$@")"
    if [ -d "$path_on_exit" ]; then
      cd "$path_on_exit" || return
    fi
  else
    printf "%s" "Command lf not found. Please intall lf first.\n"
    (exit 1) && true
  fi
}

makeSymLink () {
  local target="$1"
  local pathLink="$2"

  # Check if pathLink is relative
  if ! [[ "$pathLink" = /* ]]; then
    local symlinkDir="$(dirname "$pathLink")"
    local targetBaseName="$(basename "$target")"
    local targetDirName="$(dirname "$target")"

    local targetRelativePath="$(realpath --relative-to="$symlinkDir" "$targetDirName")"

    \ln -s "$targetRelativePath/$targetBaseName" "$pathLink"

    return
  fi

  \ln -s "$target" "$pathLink"
}

alias ln-s="makeSymLink"

unshort () {
  curl --head --location "$1" | grep "location"
}

publicip () {
  curl checkip.amazonaws.com
}

qrcode () {
  curl "qrenco.de/$*"
}

grc () {
  pushd "$user_conf_path" || return
  "$user_conf_path/utils/rgfzf.sh" "$@"
  popd || return
}

grs () {
  pushd "$user_scripts_path" || return
  "$user_conf_path/utils/rgfzf.sh" "$@"
  popd || return
}

padd () {
  mkdr "$HOME/projects"
  pushd "$HOME/projects" || return
  git clone "$@"
  popd || return
}

padb () {
  mkdr "$HOME/projects"
  pushd "$HOME/projects" || return
  clone-bare "$@"
  local ret=$?
  popd || return
  return $ret
}

rupdate () {
  # Navigate to important repos and pull the changes

  while read -r repo; do
    if ! [ -d "$repo" ]; then
      continue
    fi

    printf "%s\n" "Repo: $repo"
    printf "%s\n" "Remote: $(git -C "$repo" remote -v | awk 'NR == 1 {print $2}')"
    git -C "$repo" fetch
    git -C "$repo" pull --rebase
    git -C "$repo" submodule update --init --recursive

  done < <(
    "$user_conf_path/utils/getprojects" -f "$user_conf_path/repos/list"
    "$user_conf_path/utils/getprojects" -f "$user_conf_path/repos/device"
  )
}

themes_bat () {
  # Get other themes like tokio night
  # Ref: https://github.com/folke/tokyonight.nvim/issues/23
  if ! [ -f "$1" ]; then
    printf "%s\n" "You need to provide a file to show the themes"
    return 1
  fi

  filename="$1"
  selected_theme="$(bat --list-themes |
    fzf-defaults \
      --cycle \
      --preview-window right:80% \
      --preview "bat --theme={} --color=always $filename")"

  if [ -z "$selected_theme" ]; then
    return
  fi

  printf "%s\n" "The theme '$selected_theme' has been set temporary on 'BAT_THEME' environment variable"
  export BAT_THEME="$selected_theme"
}

themes_vivid () {
  selected_theme=$(vivid themes |
    fzf-defaults \
      --cycle \
      --preview-window 'right:70%' \
      --preview '
      printf "%s\n\n" "Theme: {}";
      LS_COLORS=$(vivid generate {});
      LS_COLORS="$LS_COLORS" eza --color=always --icons=always;
      printf "\n";
      LS_COLORS="$LS_COLORS" eza -AlF --color=always --icons=always;
      ')

  if [ -z "$selected_theme" ]; then
    return
  fi

  printf "%s\n" "The theme '$selected_theme' has been set temporary on 'LS_COLORS' environment variable"
  LS_COLORS="$(vivid generate "$selected_theme")"
  export LS_COLORS
}

config () {
  if [ -z "$*" ]; then
    pushd "$HOME/.config" || return
    fed '.'
    popd || return
  elif [ -d "$HOME/.config/$1" ]; then
    cd "$HOME/.config/$1" || return
  elif [ -f "$HOME/.config/$1" ]; then
    "$PREFERRED_EDITOR" "$HOME/.config/$1"
  else
    echo "$1 does not exist in the .config directory."
  fi
}

