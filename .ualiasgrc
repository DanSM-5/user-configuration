#!/usr/bin/env bash

######################################
#           GENERAL ALIAS            #
######################################

# Follow structure conf folders and files
export user_conf_path="$HOME/.usr_conf"
export user_scripts_path="$HOME/user-scripts"
export prj="$HOME/prj"

alias gpr="cd $prj"
alias gus="cd $user_scripts_path"
alias guc="cd $HOME/.usr_conf"
alias gvc="cd $HOME/.SpaceVim.d"
alias goh="cd $HOME"

export uprf="$HOME/.profile"
uconf="$user_conf_path/.uconfrc"
uconfg="$user_conf_path/.uconfgrc"
ualias="$user_conf_path/.ualiasrc"
ualiasg="$user_conf_path/.ualiasgrc"

cmd () {
  :
}

fzf-defaults () {
# --bind ctrl-/:toggle-preview \
  fzf --height 50% --min-height 20 --border \
    --bind "ctrl-/:change-preview-window(down|hidden|),alt-up:preview-page-up,alt-down:preview-page-down,ctrl-s:toggle-sort" \
    --header 'Press CTRL-/ to toggle preview' \
    "$@"
}

fzf_preview_ls='if [ -f {} ]; then
    bat --color=always --style=numbers {};
  else
    echo "Path: $(realpath {})"
    echo ""
    ls -AFL --color=always {}
  fi'
fzf_preview_ll='if [ -f {9..} ]; then
    bat --color=always --style=numbers {9..};
  else
    echo "Path: $(realpath {9..})"
    echo ""
    ls -AFL --color=always {9..}
  fi'

fd-defaults () {
  fd \
    "${FD_SHOW_OPTIONS[@]}" \
    "${FD_EXCLUDE_OPTIONS[@]}" \
    "$@"
}

PREFERED_EDITOR="${PREFERED_EDITOR:-vim}"

alias epf="$PREFERED_EDITOR $HOME/.profile"
alias ecf="$PREFERED_EDITOR $uconf"
alias egc="$PREFERED_EDITOR $uconfg"
alias eal="$PREFERED_EDITOR $ualias"
alias ega="$PREFERED_EDITOR $ualiasg"
alias evc="$PREFERED_EDITOR $HOME/.SpaceVim.d/init.toml"
alias ezsh="$PREFERED_EDITOR $user_conf_path/.zsh_conf"
alias ebash="$PREFERED_EDITOR $user_conf_path/.bash_conf"

# Git
alias glg="git log --oneline --decorate --graph"
alias glga="git log --oneline --all --decorate --graph"
alias gcommit="git commit -m"
alias gcomm="git commit"
alias gfetch="git fetch"
alias gpull="git pull"
alias gupdate="git fetch && git pull"
alias gpush="git push"
alias gadd="git add"
alias greset="git reset"
alias gbranch="git branch"
alias grebase="git rebase"
alias gmerge="git merge"
alias gco="git checkout"
alias gck="git checkout"
alias grm="git checkout -- ."
alias gstatus="git status"
alias gs="git status"
alias gsv="git status -v"
alias gamend="git commit --amend"
alias gdif="git diff"
alias gstash="git stash"
alias gsl="git stash list"
alias gsa="git stash apply"
alias gspop="git stash pop"
alias gsp="git stash push -m"
alias gss="git stash show"
alias gsd="git stash drop"

if command_exists delta; then
  alias gprev="git diff HEAD^..HEAD | delta"
else
  alias gprev="git diff HEAD^..HEAD | bat"
fi

gprevd () {
  local limit="$1"

  # Default limit: 1
  if [ -z "$limit" ] || [ "$limit" -le 0 ]; then
    limit=1
  fi

  if command_exists delta; then
    git diff HEAD~"$limit"..HEAD | delta
  else
    git diff HEAD~"$limit"..HEAD | bat
  fi
}

gprevr () {
  local first="$1"
  local second="$2"

  # Default first: 1
  if [ -z "$first" ] || [ "$first" -le 0 ]; then
    first=1
  fi

  # Default second: 0
  if [ -z "$second" ] || [ "$second" -le 0 ]; then
    second=0
  fi

  if command_exists delta; then
    git diff HEAD~"$first"..HEAD~"$second" | delta
  else
    git diff HEAD~"$first"..HEAD~"$second" | bat
  fi
}

# fshow - git commit browser (enter for show, ctrl-d for diff, ` toggles sort)
fshow() {
  local def_pager="less -R"
  local pager=""
  if [ -n "$__git_pager__" ]; then
    # if set pager is delta
    pager="$__git_pager__ --paging=always"
  else
    pager="$def_pager"
  fi
  local out shas sha q k
  while out=$(
      git log --graph --color=always \
          --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
      fzf --ansi --multi --no-sort --reverse --query="$q" \
          --print-query --expect=ctrl-d --bind=ctrl-s:toggle-sort); do
    q=$(head -1 <<< "$out")
    k=$(head -2 <<< "$out" | tail -1)
    shas=$(sed '1,2d;s/^[^a-z0-9]*//;/^$/d' <<< "$out" | awk '{print $1}')
    [ -z "$shas" ] && continue
    if [ "$k" = ctrl-d ]; then
      bash -c "git diff --color=always $shas | $pager"
    else
      for sha in $shas; do
        bash -c "git show --color=always $sha | $pager"
      done
    fi
  done
}

fadd () {
  local selection=($(fgf "${*:-}"))
  echo "$selection"
  if [ -n "$selection" ]; then
    git add "${selection[@]}"
  fi
}

fpad () {
  local selection=($(fgf "${*:-}"))
  echo "$selection"
  if [ -n "$selection" ]; then
    git add -p "${selection[@]}"
  fi
}

fco () {
  local selection=$(fgb "${*:-}")
  if [ -n "$selection" ]; then
    git checkout "${selection//origin\//}"
  fi
}

fck () {
  local selection=$(fgb "${*:-}")
  if [ -n "$selection" ]; then
    git checkout "${selection//origin\//}"
  fi
}

fgrm () {
  local selection=($(fgf "${*:-}"))
  if [ -n "$selection" ]; then
    git checkout -- "${selection[@]}"
  fi
}

fmerge () {
  local selection=$(fgb "${*:-}")
  echo "$selection"
  if [ -n "$selection" ]; then
    git merge "$selection"
  fi
}

fsa () {
  local selection=$(fgs "${*:-}")
  if [ -n "$selection" ]; then
    git stash apply "$selection"
  fi
}

# General commands
alias mkdr="mkdir -pv"
alias ll='ls -AlhF '
alias la='ls -A '
alias l='ls -ACF '
alias frm='\rm $(fd-defaults -tf -tx -tl | fzf-defaults --preview "bat --color=always --style=numbers {} ")'
alias frdr="rm -rf \$(fd-defaults -td -d 1 | fzf-defaults --preview \"ls --color=always -AFL {} | sed '1d;'\")"
alias fzfp="fzf-defaults --preview 'bat --color=always --style=numbers --line-range=:500 {}'"
alias pvim="vim --clean"

start () {
  file_explorer_open "$@"
}

rfv () {
  "$user_conf_path/utils/rgfzf.sh" "$@"
}

fll () {
  local selection=$(fd-defaults -td |
    fzf-defaults \
      --preview "
        echo \"Path: \$(realpath {})\"
        echo ''
        ls -AFL --color=always {}")
  if [ -n "$selection" ]; then
    \ls -alhF  --color=always "$selection"
  fi
}

lff () {
  ls -lA  |
    sed '1d' |
    fzf-defaults --preview 'if [ -f {9..} ]; then
        bat --color=always --style=numbers {9..}
      else
        echo "Path: $(realpath {9..})"
        echo ""
        ls -AFL --color=always {9..} 2> /dev/null || echo "Cannot access directory {}"
      fi' |
    awk '{ print $9 }'
}

# lf () {
#   ls -a  |
#     sed '1d;2d' |
#     fzf-defaults --preview 'if [ -f {} ]; then
#         bat --color=always --style=numbers {}
#       else
#         echo "Path: $(realpath {})"
#         echo ""
#         ls -AFL --color=always {} 2> /dev/null || echo "Cannot access directory {}"
#       fi'
# }

lfd () {
  fd-defaults |
    fzf-defaults --preview 'if [ -f {} ]; then
        bat --color=always --style=numbers {}
      else
        echo "Path: $(realpath {})"
        echo ""
        ls -AFL --color=always {} 2> /dev/null || echo "Cannot access directory {}"
      fi'
}

# experimental
lfa () {
  local selection=$(cd "/" && fd-defaults |
    fzf-defaults --preview 'if [ -f {} ]; then
        bat --color=always --style=numbers {}
      else
        echo "Path: $(realpath {} 2> /dev/null || echo File cannot be opened)"
        echo ""
        ls -AFL --color=always {} 2> /dev/null || echo "Cannot access directory {}"
      fi')
  echo "$selection"
}

fcd () {
  local location="${1:-.}"
  local query="${@:2}"
  local pattern="."
  local selection=""

  if ! [ -d "$location" ]; then
    pattern="$location"
    location="$HOME"
  fi

  # old preview "ls --color=always -alhF {} | sed '1d;2d;3d'"
  selection=$(fd-defaults -tl -td "$pattern" "$location" |
    fzf-defaults --query "$query" \
      --header "(ctrl-/) Search in: $location" \
      --preview "
        echo \"Path: \$(realpath {})\"
        echo ''
        ls --color=always -AFL {} 2> /dev/null || echo 'Cannot access directory {}'")
  if [ -z "$selection" ]; then
    return 1
  fi

  cd $selection
}

# sed '1d;2d'
fcdd () {
  local query="$@"
  local selection=""

  selection=$(fd-defaults -tl -td |
    fzf-defaults \
      --query "$query" \
      --preview "
        echo \"Path: \$(realpath {})\"
        echo ''
        ls --color=always -AFL {} 2> /dev/null || echo 'Cannot access directory {}'")

  if [ -z "$selection" ]; then
    return 1
  fi

  cd $selection
}

fcde () {
  local location="${1:-.}"
  local pattern="${2:-.}"
  local query="${@:3}"

  if ! [ -d "$location" ]; then
    echo "Invalid location. Defaulting to cwd."
    location="$(pwd)"
  fi

  local selection=$(
    fd-defaults -L -tf "$pattern" "$location" \
      -x dirname {} |
    sort -u |
    fzf-defaults \
      --preview "ls -AFL {}" \
      --header "(ctrl-/) Search in: $location" \
      --query "$query")
  if [ -z "$selection" ]; then
    return
  fi

  cd "$selection"
}

fcda () {
  local selection=""

  selection=$(cd / && fd-defaults -tl -td | fzf-defaults --preview "
    echo \"Path: \$(realpath {})\"
    echo ''
    ls --color=always -AFL {} 2> /dev/null || echo 'Cannot access directory {}'")
  if [ -n "$selection" ]; then
    cd $selection
  fi
}

fed () {
  local location="${1:-.}"
  local query="${@:3}"
  local pattern="."
  local editor="${PREFERED_EDITOR:-vim}"

  if ! [ -d "$location" ]; then
    pattern="$location"
    location="$HOME"
  fi

  local selection=($(fd-defaults -L -tf "$pattern" "$location" |
    fzf-defaults \
      --multi \
      --preview "bat --color=always --style=numbers {}" \
      --header "(ctrl-/) Search in: $location" \
      --query "$query"))
  if [ -z "$selection" ]; then
    return
  fi
  if [ -n "$2" ] && [ "$2" != "-" ]; then
    editor="$2"
  fi

  $editor "${selection[@]}"
}

fedd () {
  local query="${@:2}"
  local editor="${PREFERED_EDITOR:-vim}"
  local selection=$(fd-defaults -L -tf | fzf-defaults --preview "bat --color=always --style=numbers {}" --query "$query")
  if [ -z "$selection" ]; then
    return
  fi
  if [ -n "$1" ] && [ "$1" != "-" ]; then
    editor="$1"
  fi
  $editor "$selection"
}

fif () {
  if [ ! "$#" -gt 0 ]; then
    echo 'Need a string to search for!'
    return 1;
  fi

  rg --files-with-matches --no-messages "$*" |
    fzf-defaults \
      --preview "
        highlight -O ansi -l {} 2> /dev/null |
        rg --colors 'match:bg:yellow' --ignore-case --pretty --context 10 '$*' || rg --ignore-case --pretty --context 10 '$*' {}"
}

fdirs () {
  local selection="$(dirs -v |
    fzf-defaults \
    --preview '
      echo "Path: {2..}"
      echo ''
      ls -AFL --color=always $(bash -c "echo "{2..})' |
    awk '{print $1}')"

  if [ -n "$selection" ]; then
    pushd "+$selection"
  fi
}

fenv () {
  local tmpfile="$(mktemp)"
  # Cleanup file on exit
  trap "rm -- '$tmpfile'" EXIT

  while IFS='=' read -r -d '' n v; do
    printf "%s=%s\n" "$n" "${v//$'\n'}"
  done < <(env -0) > "$tmpfile"


  # FZF process
  # --expect will return an arry with the expected key
  # as first element if key is pressed
  local output=($(cat -v "$tmpfile" |
    fzf-defaults \
      --preview 'printf "%q" {}' --preview-window up:3:hidden:wrap \
      --bind 'ctrl-/:toggle-preview' \
      --bind 'ctrl-s:toggle-sort' \
      --bind 'ctrl-y:execute-silent(echo -n {} | $clipboard_copy)+abort' \
      --expect 'ctrl-h,ctrl-v' \
      --color header:italic \
      --header 'Press CTRL-Y to copy command into clipboard'))

  # Subshell to keep helper functions as local
  (
    getKey () {
      cut -d '=' -f "1" | trim
    }

    getValue () {
      cut -d '=' -f "2-" | trim
    }

    case ${output[1]} in
      ctrl-h)
        # Print key only
        echo "${output[@]:1}" | getKey
        ;;
      ctrl-v)
        # Print value only
        echo "${output[@]:1}" | getValue
        ;;
      *)
        # Print everything if selected
        if [ -n "${output[1]}" ]; then
          echo "${output[@]}"
        fi
        ;;
    esac
  )
}

fnr () {
  if ! [ -f package.json ]; then
    echo "No package.json in dir $(pwd)"
    return 1
  fi

  local query="${*}"
  local selection="$(cat package.json |
    jq -r '.scripts | keys[]' |
    sort |
    fzf --query "$query" --height 50% --min-height 20 --border)"

  if [ -z "$selection" ]; then
    return 1
  fi

  npm run "$selection"
}

# Example quick_access
# export quick_access=(\
# "$HOME\n"\
# # "/mnt/c\n"\
# # "/mnt/c/Users/user\n"\
# "$prj\n"\
# "$user_conf_path\n"\
# "$user_scripts_path\n"\
# # "/tmp"\
# )

# Example quick_edit
# export quick_edit=(\
# "$user_conf_path/.uconfgrc\n"\
# "$user_conf_path/.uconfrc\n"\
# "$user_conf_path/.ualiasgrc\n"\
# "$user_conf_path/.ualiasrc\n"\
# "$HOME/.SpaceVim.d/init.toml\n"\
# "$HOME/.SpaceVim.d/autoload/config.vim"\
# )

# List folders for quick navigation
# Requires: quick_access=()
qnv () {
  if [ -z "$quick_access" ]; then
    return
  fi
  local selection=$(printf "%s\n" "${quick_access[@]}" |
    fzf-defaults --preview "
      echo \"Path: \$(realpath {} 2> /dev/null || echo 'Unable to display')\"
      echo ''
      ls --color=always -AFL {} 2> /dev/null || echo 'No preview available'")
  if [ -n "$selection" ]; then
    cd $selection
  fi
}

# List files for quick edit
# Requires: quick_edit
qed () {
  if [ -z "$quick_edit" ]; then
    return
  fi
  local editor="$1"
  local selection=$(printf "%s\n" "${quick_edit[@]}" |
    fzf-defaults --preview "
      bat --color=always --style=numbers {} 2> /dev/null || echo 'Cannot preview {}'")

  if ! [ -f "$selection" ]; then
    return
  fi
  if [ -z "$editor" ]; then
    editor="${PREFERED_EDITOR:-vim}"
  fi
  $editor $selection
}

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Sys Alias
alias aptup="sudo apt-get update && sudo apt-get upgrade" 
alias aptupd="sudo apt-get update"
alias aptupg="sudo apt-get upgrade"
alias aptin="sudo apt-get install"
alias aptrm="sudo apt-get remove"

# Node & NPM
alias npm-list="npm list -g --dept=0"
alias nlg="npm list -g --dept=0"
alias nr="npm run"

# Navigation
# Nav up n directories
up () {
  local d=""
  local limit="$1"

  # Default to limit of 1
  if [ -z "$limit" ] || [ "$limit" -le 0 ]; then
    limit=1
  fi

  for (( i=1; i<=limit; i++ )); do
    d="../$d"
  done

  # perdorm cd. Show error if cd fails
  if ! cd "$d"; then
    echo "Couldn't go up $limit dirs."
  fi
}

.. () {
  up "$@"
}

... () {
  up 2
}

# Sourcing
alias spf="source $HOME/.${SHELL_NAME}rc || source .profile || echo 'Source profile encountered an error'"
alias scfg="source $user_conf_path/.uconfrc"
alias sgcf="source $user_conf_path/.uconfgrc"
alias sals="source $user_conf_path/.ualiasrc"
alias sgal="source $user_conf_path/.ualiasgrc"

alias psh="powershell.exe"
alias pwsh="pwsh.exe"
alias cps="pwsh.exe -nolo -nopro -nonin -c"

# Trim utilities
nospace () {
  tr -d "[:space:]"
}

ltrim () {
  sed -E 's/^[[:space:]]*//'
}

rtrim () {
  sed -E 's/[[:space:]]*$//'
}

trim () {
  ltrim | rtrim
}

# Open temp file on vim
ntemp () {
  "${PREFERED_EDITOR:-vim}" "/tmp/temp-$(uuidgen 2>/dev/null || date +%d-%m-%Y_%H-%M-%S).txt"
}

# extract files
ex () {
  if [ -f "$1" ]; then
    case $1 in
      *.tar.bz2)    tar xjvf $1;;
      *.tar.gz)     tar xzvf $1;;
      *.bz2)        bunzip2 $1;;
      *.rar)        unrar x $1;;
      *.gz)         gunzip $1;;
      *.tar)        tar xvf $1;;
      *.tbz2)       tar xjvf $1;;
      *.tgz)        tar xzvf $1;;
      *.zip)        unzip $1;;
      *.Z)          uncompress $1;;
      *.7z)         7z x $1;;
      *.deb)        ar x $1;;
      *.tar.xz)     tar xvf $1;;
      *.tar.zst)    unzstd $1;;
      *)            echo "'$1' cannot be extracted via ex()!";;
    esac
  else
    echo "'$1' is not a file"
  fi
}

# System executables
export clipboard_paste=""
export clipboard_copy=""
gallery_dl_commd="gallery-dl"
yt_dlp_commd="yt-dlp"
mpv_commd='mpv'

# Standard wrapper function names that should work on all platforms
clipboard_pastew () {
  "$clipboard_paste" "$@"
}
clipboard_copyw () {
  "$clipboard_copy" "$@"
}

file_explorer_open () {
  :
}

gallery-dlw () {
  "$gallery_dl_commd" "$@"
}

yt-dlpw () {
  "$yt_dlp_commd" "$@"
}

yt-dlp-play () {
  "$yt_dlp_commd" -o - "$@"
}

yt-dlp-play-quality () {
  yt-dlp-play -f bestvideo+bestaudio/best "$@"
}

mpvw () {
  echo "Playing: $@"
  "$mpv_commd" "$@"
}

webtorrentw () {
  webtorrent "$@"
}

mpvp () {
  # mpv play
  # declare url=${*:-$(</dev/stdin)}
  local use_stdin=false
  for arg do
    shift
    if [[ "$arg" = "-" ]]; then
      # Remove - arg
      use_stdin=true
      continue
    fi
    set -- "$@" "$arg"
  done

  if [ "$use_stdin" = true ]; then

    read -t 5 url
    if [ -z "$url" ]; then
      echo "No url provided"
      (exit 1) && true
    fi

    echo "Playing: $url"
    yt-dlp-play-quality "$url" | "$mpv_commd" --cache "${@:2}"  -
  elif [ -n "$1" ]; then
    echo "Playing: $1"
    yt-dlp-play-quality "$1" | "$mpv_commd" --cache "${@:2}"  -
  else
    echo "No url provided"
    (exit 1) && true
  fi
}

dwi () {
  local img_url="$("$clipboard_paste" | trim)"
  if [ -z "$img_url" ]; then
    echo "No image url"
    return 1
  fi

  echo "Downloading: $img_url"

  "$gallery_dl_commd" "$img_url" "$@"
}

dwv () {
  local vid_url="$("$clipboard_paste" | trim)"
  if [ -z "$vid_url" ]; then
    echo "No video url"
    return 1
  fi

  echo "Downloading: $vid_url" "$@"

  "$yt_dlp_commd" "$vid_url"
}

# Wrapper for ytfzf to launch on windows mpv player
mpvl () {
  local selection=$(ytfzf -L "$@")
  if [ -n "$selection" ]; then
    "$mpv_commd" "$selection"
  fi
}

yf () {
  # Set starting page with flag -p[n]
  local startpage=1
  local direct_play=false
  local linkOnly=false
  local selection=""
  for arg do
    shift
    if [[ "$arg" =~ -p[0-9]+ ]]; then
      # Remove -p arg and use value as pages_start
      startpage="${arg:2}"
      continue
    elif [[ "$arg" = "--direct-play" ]]; then
      direct_play=true
      continue
    elif [[ "$arg" = "-L" ]]; then
      # -L is always called in this wrapper
      # Detect it here to prevent playback
      linkOnly=true
    fi
    set -- "$@" "$arg"
  done

  if [[ "$linkOnly" = false ]] && [[ "$direct_play" = true ]]; then
    selection="$(pages_start="$startpage" ytfzf -L "$@")"

    if [ -z "$selection" ]; then
      return 1 
    fi

    mpvp "$selection"
    return
  fi

  pages_start="$startpage" ytfzf "$@"
}

yfd () {
  yf --direct-play "$@"
}

play () {
  local url="$("$clipboard_paste" | trim)"
  if [ -z "$url" ]; then
    echo "No url in clipboard"
    return 1
  fi

  if [[ "$url" =~ ".torrent" ]] ||
    [[ "$url" =~ "magnet:" ]] ||
    [[ "$url" =~ "webtorrent://" ]] ||
    [[ "$url" =~ "peerflix://" ]]; then
    webtorrentw --mpv "$url" "$@"
  else
    mpvw "$url" "$@"
  fi
}

plpp () {
  local url="$("$clipboard_paste")"
  if [ -z "$url" ]; then
    echo "No url in clipboard"
    return 1
  fi
  mpvp "$url"
}

tplay () {
  local url="$("$clipboard_paste" | trim)"
  if [ -z "$url" ]; then
    echo "No url in clipboard"
    return 1
  fi

  if [ "$1" = '-l' ]; then
    webtorrentw --mpv "$url" -u 1 "${@:2}" 
  else
    webtorrentw --mpv "$url" "$@"
  fi
}

getClipboardPath () {
  local filepath="$("$clipboard_paste" | tr -d "\r\n")"

  if [ -z "$filepath" ]; then
    echo ""
    return
  fi

  if [[ -f "$filepath" ]]; then
    filepath="$(dirname "$filepath")"
  elif [[ -d "$filepath" ]]; then
    :
  else
    echo ""
    return
  fi

  echo "$(realpath "$filepath")"
}

ccd () {
  local filepath="$(getClipboardPath)"

  if [[ -z "$filepath" ]]; then
    echo "None or wrong path provided"
    return 1
  fi

  cd "$filepath"
}

ocd () {
  local filepath="$(getClipboardPath)"

  if [[ -z "$filepath" ]]; then
    echo "None or wrong path provided"
    return 1
  fi

  file_explorer_open "$filepath"
}

if [ "$IS_WSL" = true ]; then
  export clipboard_paste="pbpaste.exe"
  export clipboard_copy="pbcopy.exe"

  gallery_dl_commd="gallery-dl.exe"
  yt_dlp_commd="yt-dlp.exe"
  mpv_commd='mpv'

  dgl () {
    pushd "$WIN_HOME"
    pwsh.exe -NoLogo -NonInteractive -Command "Download-Gdl $@"
    popd
  }

  cmd () {
    cmd.exe /c "$@"
  }

  file_explorer_open () {
    pwsh.exe -nolo -nonin -nopro -c Start-Process \""$@"\"
  }

  getPath () {
    local filepath="$@"

    if [ -z "$filepath" ]; then
      echo ""
      return
    fi

    local linuxpath="" windowspath=""

    if [[ -f "$filepath" ]] || [[ -d "$filepath" ]]; then # Valid unix path
      linuxpath="$(wslpath -au "$(wslpath -aw $filepath)")"
    else # win path
      linuxpath="$(wslpath -au "$filepath")"
    fi

    if [ -d "$linuxpath" ]; then
      windowspath="$(wslpath -aw "$linuxpath")"
    elif [ -f "$linuxpath" ]; then
      windowspath="$(dirname "$linuxpath" | xargs -i wslpath -aw {})"
    fi

    # Return escaped string to allow \f \n \t directories
    echo "$(printf "%q" "$windowspath" | sed 's/\\ / /g')"
  }

  start () {
    local trimmed_path="$(echo "$@" | trim)"
    local filepath="$(getPath "$trimmed_path")"

    file_explorer_open "$filepath"
  }

  if command_exists mpv; then 
    if [ "$IS_ZSH" = true ] && [[ $(type mpv) =~ function ]]; then
      unset -f mpv
    elif [ "$IS_BASH" = true ] && [[ $(type -t mpv) == function ]]; then
      unset -f mpv
    fi
  fi

  # MPV wrapper for WSL
  if ! command_exists mpv; then
    if command_exists mpv.com; then
      mpv_commd="mpv.com"
      mpv () {
        mpv.com "$@" 
      }

    elif command_exists mpv.exe; then
      mpv_commd="mpv.exe"
      mpv () {
        mpv.exe "$@" 
      }
    fi
  fi

  # yt-dlp wrapper for WSL
  if ! command_exists yt-dlp; then
    yt-dlp () {
      yt-dlp.exe "$@" 
    }
  fi

  # gallery-dl wrapper for WSL
  if ! command_exists gallery-dl; then
    gallery-dl () {
      gallery-dl.exe "$@" 
    }
  fi

  webtorrentw () {
    cmd webtorrent "$@"
  }

  # Windows override of yf
  yf () {
    # Set starting page with flag -p[n]
    local startpage=1
    local linkOnly=false
    local direct_play=false
    for arg do
      shift
      if [[ "$arg" =~ "-p[0-9]+" ]]; then
        # Remove -p arg and use value as pages_start
        startpage="${arg:2}"
        continue
      elif [[ "$arg" = "-L" ]]; then
        # -L is always called in this wrapper
        # Detect it here to prevent playback
        linkOnly=true
        continue
      elif [[ "$arg" = "--direct-play" ]]; then
        direct_play=true
        continue
      fi
      set -- "$@" "$arg"
    done

    local selection="$(pages_start="$startpage" ytfzf -L "$@")"

    if [ -z "$selection" ]; then
      return 1 
    fi

    if [[ "$linkOnly" = true ]]; then
      echo "$selection"
      return
    elif [[ "$direct_play" = true ]]; then
      mpvp "$selection"
    else
      mpvw "$selection"
    fi
  }

  linuxToWindowsPath () {
    echo "$(wslpath -aw "$1")"
  }

  windowsToLinuxPath () {
    echo "$(wslpath -au "$1")"
  }

  getClipboardPath () {
    local filepath="$("$clipboard_paste" | trim | tr -d "\r\n")"

    if [ -z "$filepath" ]; then
      echo ""
      return
    fi

    local linuxpath="" windowspath=""

    if [[ -f "$filepath" ]] || [[ -d "$filepath" ]]; then # Valid unix path
      linuxpath="$(wslpath -au "$(wslpath -aw $filepath)")"
    else # win path
      linuxpath="$(wslpath -au "$filepath")"
    fi

    if [ -d "$linuxpath" ]; then
      windowspath="$(wslpath -aw "$linuxpath")"
    elif [ -f "$linuxpath" ]; then
      windowspath="$(dirname "$linuxpath" | xargs -i wslpath -aw {})"
    fi

    # Return escaped string to allow \f \n \t directories
    echo "$(printf "%q" "$windowspath" | sed 's/\\ / /g')"
  }

  ccd () {
    local filepath="$(getClipboardPath)"

    if [[ -z "$filepath" ]]; then
      echo "None or wrong path provided"
      return 1
    fi

    cd "$(wslpath -au "$filepath")"
  }

  # ocd () {
  #   local filepath="$("$clipboard_paste" | tr -d "\r\n" )"

  #   if [ -z "$filepath" ]; then
  #     return 1
  #   fi

  #   local linuxpath="" windowspath=""

  #   if [[ -f "$filepath" ]] || [[ -d "$filepath" ]]; then # Valid unix path
  #     linuxpath="$(wslpath -au "$(wslpath -aw $filepath)")"
  #   else # win path
  #     linuxpath="$(wslpath -au "$filepath")"
  #   fi

  #   if [ -d "$linuxpath" ]; then
  #     local windowspath="$(wslpath -aw "$linuxpath")"
  #   elif [ -f "$linuxpath" ]; then
  #     local windowspath="$(dirname "$linuxpath" | xargs -i wslpath -aw {})"
  #   else
  #     echo "Invalid path"
  #     return 1
  #   fi

  #   pwsh.exe -nolo -nonin -nopro -c Start-Process \""$windowspath"\"
  # }

else

  # function for compliancy
  mpvl () {
    ytfzf "$@"
  }

  if [ "$IS_TERMUX" = true ]; then
    alias tcopy="termux-clipboard-set"
    alias tpaste="termux-clipboard-get"
    export clipboard_copy="termux-clipboard-set"
    export clipboard_paste="termux-clipboard-get"

    clipboard_copyw () {
      termux-clipboard-set "$@"
    }

    clipboard_pastew () {
      termux-clipboard-get "$@"
    }

    # termux mpv function wrapper
    mpv () {
      local use_stdin=false

      for arg do
        shift
        if [[ "$arg" = "-" ]]; then
          # Remove -p arg and use value as pages_start
          use_stdin=true
          continue
        fi
        set -- "$@" "$arg"
      done

      if [ "$use_stdin" = true ]; then

        read -t 5 url
        if [ -z "$url" ]; then
          echo "No url provided"
          (exit 1) && true
        fi

        am start --user 0 -a android.intent.action.VIEW -d "$url" is.xyz.mpv/.MPVActivity
      elif [ -n "$1" ]; then
        am start --user 0 -a android.intent.action.VIEW -d "$@" is.xyz.mpv/.MPVActivity
      else
        echo "No url provided"
        (exit 1) && true
      fi
    }
  elif [ "$IS_LINUX" = true ]; then
    clipboard_copyw () {
      xsel -ib "$@"
    }

    clipboard_pastew () {
      xsel -ob "$@"
    }

    export clipboard_copy="$user_conf_path/utils/copy-helper-linux.sh"
    export clipboard_paste="$user_conf_path/utils/paste-helper-linux.sh"

    file_explorer_open () {
      xdg-open "$@" &
    }

  elif [ "$IS_MAC" = true ]; then
    export clipboard_copy="pbcopy"
    export clipboard_paste="pbpaste"

    file_explorer_open () {
      open "$@"
    }

  elif [ "$IS_GITBASH" = true ]; then
    export clipboard_copy="pbcopy"
    export clipboard_paste="pbpaste"

    file_explorer_open () {
      # Special parsing for windows paths
      local location_path="$(printf "%q" "$@" |
        trim |
        sed -re "s|^/([a-zA-Z])/(.*$)|\u\1:/\2|g" |
        tr '/' '\\')"

      location_path="$(printf "%q" "$location_path" | sed 's/\\ / /g')"

      pwsh.exe -nolo -nonin -nopro -c Start-Process \""$location_path"\"
    }

    cmd () {
      cmd.exe //c "$@"
    }

    dgl () {
      pwsh.exe -NoLogo -NonInteractive -Command "Download-Gdl $@"
    }
  fi
fi

fmpv () {
  local initial="$@"
  local selection="$(fd -tf |
    fzf -m --height 50% --min-height 20 --border -q "$initial")"
  if [ -z "$selection" ]; then
    return
  fi
  local quoted=$(echo $selection |
    awk '{ printf "\"""%s""\""" ", $0 }')
  bash -c "$mpv_commd $quoted"
}

ptc () {
  local location="${1:-$HOME}"
  local query="${@:2}"
  local pattern="."
  local selection=""

  if ! [ -d "$location" ]; then
    pattern="$location"
    location="$HOME"
  fi

  # old preview "ls --color=always -alhF {} | sed '1d;2d;3d'"
  selection=$(fd-defaults -tl -td -tf -L "$pattern" "$location" |
    fzf-defaults --query "$query" \
      --header "(ctrl-/) Search in: $location" \
      --preview "if [ -f {} ]; then
          bat -pp --color=always --style=numbers {}
        else
          echo \"Path: \$(realpath {})\"
          echo ''
          ls --color=always -AFL  {} 2> /dev/null || echo 'Cannot access directory {}'
        fi")
  if [ -z "$selection" ]; then
    return 1
  fi
  
  selection="$(realpath "$selection")"

  echo "$selection" | clipboard_copyw
}

# If path issues, add VS Code path manually
# export PATH="${WIN_HOME}/AppData/Local/Programs/Microsoft VS Code/bin:$PATH"

# Dependencies
# export PATH="$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

getShellAliasAndFunctions () {
  if [ "$IS_BASH" = true ]; then
    {
      # Functions
      typeset -F | awk '{ if ( $3 !~ /_.+/) { print $3 } }';
      # Aliases
      # alias | awk '{ split($2,o,"="); print o[1] }'
      compgen -a
    }
  else
    {
      # Functions
      print -l ${(ok)functions} |
        awk '{ if ($1 !~ /^_.+/) { print $1 } }';
      # Aliases
      # alias | cut -d '=' -f 1
      compgen -a
    }
  fi
}

fcmd () {
  local available_commands="$(getShellAliasAndFunctions | sort)"
  local tmpfile="$(mktemp)"
  # Cleanup file on exit
  trap "rm -- '$tmpfile'" EXIT

  # Get the output of type and store it in tmpfile
  for cm in $(echo ${available_commands}); do
    echo ""
    type -f "$cm" 2>/dev/null || type "$cm" 2>/dev/null
  done > "$tmpfile"

  # --preview "rg -A 20 -B 1 --text --color=always '^{} ' $tmpfile" \
  echo "$available_commands" |
    fzf-defaults \
      --preview "
        rg -A 50 -B 1 -m 1 '^{} ' $tmpfile |
          bat -l bash --color=always -p -H 2" \
      --preview-window right:70% \
      --bind 'ctrl-y:execute-silent(echo -n {} | $clipboard_copy)+abort' || return 0
}

# TODO: Using `fd --hidden --follow -td -d 1`
# has issues with file names with spaces.
# Investigate if fixin the issue is faster
countFiles () {
  local searchSize="$1"
  local fdArgs=(${@:2})

  (
    printSimple () {
      printf "$1\t$(fd --hidden "${fdArgs[@]}" . "$1" | wc -l)\n"
    }

    printWithFileSize () {
      local count="$(fd --hidden "${fdArgs[@]}" . "$1" | wc -l)"
      printf "$(du -sh "$1" 2> /dev/null)\t$count\n"
    }

    local printFunc=printSimple

    if [ "$searchSize" = true ]; then
      printFunc=printWithFileSize
    fi

    # for dirl in $(fd ${FD_SHOW_OPTIONS[@]} ${FD_EXCLUDE_OPTIONS[@]} -td -d 1); do
    for dirl in .*/ */; do
      $printFunc "$dirl"
    done | column -t -s $'\t'
  )
}

cdirs () {
  printf "Counting directories in $(pwd):\n\n"
  local size=false
  [ "$1" = -s ] && size=true
  countFiles "$size" -td
}

cfiles () {
  printf "Counting files in $(pwd):\n\n"
  [ "$1" = -s ] && size=true
  countFiles "$size" -tf
}

cevery () {
  printf "Counting all files in $(pwd):\n\n"
  [ "$1" = -s ] && size=true
  countFiles "$size"
}

bdif () {
  git rev-parse HEAD > /dev/null 2>&1 || return

  git diff --name-only --relative --diff-filter=d | xargs bat --diff
}

publicip () {
  curl checkip.amazonaws.com
}
